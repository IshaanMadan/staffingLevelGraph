<!doctype html>
<html lang="en">

<head>
	<meta charset="UTF-8" />
	<title>Phaser - Staffing Level Graph</title>
	<script src="//cdn.jsdelivr.net/phaser/2.6.2/phaser.min.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/date-fns/1.28.5/date_fns.min.js" /></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.4/lodash.min.js"></script>

	<style type="text/css">
		body {
			margin: 0;
			background: #e0e0e0;
			text-align: center;
		}

		canvas,
		iframe {
			position: absolute;
			top: 0;
			bottom: 0;
			left: 0;
			right: 0;
			margin: auto;
		}
	</style>
	<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
</head>

<body>
	<p>Select to Edit a Layer</p>
	<select class="onTopSelect">
		<option value = "" selected>None</option>
		<option value = "avail" >Available</option>
		<option value = "minReq" >MinRequired</option>
		<option value = "maxReq" >MaxRequired</option>
		<option value = "sick" >Sick</option>
	</select>

	<script type="text/javascript">
		_ = _.noConflict(); // lets call ourselves _u

		//shift data object
		var floorRefObj = {
			1: 0,
			2: 30,
			4: 15,
			12: 5,
		}
		var minutesInMinuteIndexObj = {
			1: {
				0: 0

			},
			2: {
				0: 0,
				30: 1,

			},
			4: {
				0: 0,
				15: 1,
				30: 2,
				45: 3,

			},
			12: {
				0: 0,
				5: 1,
				10: 2,
				15: 3,
				20: 4,
				25: 5,
				30: 6,
				35: 7,
				40: 8,
				45: 9,
				50: 10,
				55: 11,

			}
		}

		let getInverseTimeIndexesObj = {
			1: {
				0: 0

			},
			2: {
				0: 0,
				30: 1,

			},
			4: {
				0: 0,
				15: 3,
				30: 2,
				45: 1,

			},
			12: {
				0: 0,
				5: 11,
				10: 10,
				15: 9,
				20: 8,
				25: 7,
				30: 6,
				35: 5,
				40: 4,
				45: 3,
				50: 2,
				55: 1,

			}
		}

		var shiftData = {
			"shiftScale": 1,
			"myShift": [],
			"sickLevels": {
				"0 - 1": 0,
				"1 - 2": 0,
				"2 - 3": 0,
				"3 - 4": 0,
				"4 - 5": 5,
				"5 - 6": 5,
				"6 - 7": 5,
				"7 - 8": 5,
				"8 - 9": 5,
				"9 - 10": 0,
				"10 - 11": 0,
				"11 - 12": 6,
				"12 - 13": 4,
				"13 - 14": 0,
				"14 - 15": 3,
				"15 - 16": 4,
				"16 - 17": 0,
				"17 - 18": 0,
				"18 - 19": 0,
				"19 - 20": 0,
				"20 - 21": 0,
				"21 - 22": 0,
				"22 - 23": 0,
				"23 - 24": 0
			},
			"availableLevels": [],
			"minRequiredLevels": [],
			"maxRequiredLevels": [],
		}

		var staffDataFromServer = { // to be removed upon server integration(Mock)		-- complete
			"currentDay": 1507276403064,
			"staffingLevelSetting": {
				"detailLevelMinutes": 15,
			},
			"staffingLevelInterval": [{
					"sequence": 0,
					"minNoOfStaff": 10,
					"maxNoOfStaff": 12,
					"availableNoOfStaff": 5
				},
				{
					"sequence": 1,
					"minNoOfStaff": 10,
					"maxNoOfStaff": 12,
					"availableNoOfStaff": 6
				},
				{
					"sequence": 2,
					"minNoOfStaff": 10,
					"maxNoOfStaff": 12,
					"availableNoOfStaff": 6
				},
				{
					"sequence": 3,
					"minNoOfStaff": 10,
					"maxNoOfStaff": 12,
					"availableNoOfStaff": 5
				},
				{
					"sequence": 4,
					"minNoOfStaff": 8,
					"maxNoOfStaff": 10,
					"availableNoOfStaff": 9
				},
				{
					"sequence": 5,
					"minNoOfStaff": 8,
					"maxNoOfStaff": 10,
					"availableNoOfStaff": 9
				},
				{
					"sequence": 6,
					"minNoOfStaff": 8,
					"maxNoOfStaff": 10,
					"availableNoOfStaff": 10
				},
				{
					"sequence": 7,
					"minNoOfStaff": 8,
					"maxNoOfStaff": 10,
					"availableNoOfStaff": 9
				},
				{
					"sequence": 8,
					"minNoOfStaff": 7,
					"maxNoOfStaff": 13,
					"availableNoOfStaff": 10
				},
				{
					"sequence": 9,
					"minNoOfStaff": 7,
					"maxNoOfStaff": 13,
					"availableNoOfStaff": 10
				},
				{
					"sequence": 10,
					"minNoOfStaff": 7,
					"maxNoOfStaff": 13,
					"availableNoOfStaff": 10
				},
				{
					"sequence": 11,
					"minNoOfStaff": 7,
					"maxNoOfStaff": 13,
					"availableNoOfStaff": 10
				},
				{
					"sequence": 12,
					"minNoOfStaff": 11,
					"maxNoOfStaff": 12,
					"availableNoOfStaff": 9
				},
				{
					"sequence": 13,
					"minNoOfStaff": 11,
					"maxNoOfStaff": 12,
					"availableNoOfStaff": 9
				},
				{
					"sequence": 14,
					"minNoOfStaff": 11,
					"maxNoOfStaff": 13,
					"availableNoOfStaff": 9
				},
				{
					"sequence": 15,
					"minNoOfStaff": 11,
					"maxNoOfStaff": 13,
					"availableNoOfStaff": 12
				},
				{
					"sequence": 16,
					"minNoOfStaff": 9,
					"maxNoOfStaff": 14,
					"availableNoOfStaff": 11
				},
				{
					"sequence": 17,
					"minNoOfStaff": 9,
					"maxNoOfStaff": 14,
					"availableNoOfStaff": 11
				},
				{
					"sequence": 18,
					"minNoOfStaff": 9,
					"maxNoOfStaff": 14,
					"availableNoOfStaff": 11
				},
				{
					"sequence": 19,
					"minNoOfStaff": 9,
					"maxNoOfStaff": 14,
					"availableNoOfStaff": 10
				},
				{
					"sequence": 20,
					"minNoOfStaff": 10,
					"maxNoOfStaff": 11,
					"availableNoOfStaff": 13
				},
				{
					"sequence": 21,
					"minNoOfStaff": 10,
					"maxNoOfStaff": 11,
					"availableNoOfStaff": 12
				},
				{
					"sequence": 22,
					"minNoOfStaff": 10,
					"maxNoOfStaff": 11,
					"availableNoOfStaff": 12
				},
				{
					"sequence": 23,
					"minNoOfStaff": 10,
					"maxNoOfStaff": 11,
					"availableNoOfStaff": 12
				},
				{
					"sequence": 24,
					"minNoOfStaff": 12,
					"maxNoOfStaff": 14,
					"availableNoOfStaff": 13
				},
				{
					"sequence": 25,
					"minNoOfStaff": 12,
					"maxNoOfStaff": 14,
					"availableNoOfStaff": 13
				},
				{
					"sequence": 26,
					"minNoOfStaff": 12,
					"maxNoOfStaff": 14,
					"availableNoOfStaff": 13
				},
				{
					"sequence": 27,
					"minNoOfStaff": 12,
					"maxNoOfStaff": 14,
					"availableNoOfStaff": 13
				},
				{
					"sequence": 28,
					"minNoOfStaff": 7,
					"maxNoOfStaff": 9,
					"availableNoOfStaff": 6
				},
				{
					"sequence": 29,
					"minNoOfStaff": 7,
					"maxNoOfStaff": 9,
					"availableNoOfStaff": 6
				},
				{
					"sequence": 30,
					"minNoOfStaff": 7,
					"maxNoOfStaff": 9,
					"availableNoOfStaff": 6
				},
				{
					"sequence": 31,
					"minNoOfStaff": 7,
					"maxNoOfStaff": 9,
					"availableNoOfStaff": 6
				},
				{
					"sequence": 32,
					"minNoOfStaff": 8,
					"maxNoOfStaff": 10,
					"availableNoOfStaff": 9
				},
				{
					"sequence": 33,
					"minNoOfStaff": 9,
					"maxNoOfStaff": 10,
					"availableNoOfStaff": 9
				},
				{
					"sequence": 34,
					"minNoOfStaff": 8,
					"maxNoOfStaff": 10,
					"availableNoOfStaff": 9
				},
				{
					"sequence": 35,
					"minNoOfStaff": 8,
					"maxNoOfStaff": 10,
					"availableNoOfStaff": 9
				},
				{
					"sequence": 36,
					"minNoOfStaff": 9,
					"maxNoOfStaff": 11,
					"availableNoOfStaff": 12
				},
				{
					"sequence": 37,
					"minNoOfStaff": 9,
					"maxNoOfStaff": 11,
					"availableNoOfStaff": 12
				},
				{
					"sequence": 38,
					"minNoOfStaff": 9,
					"maxNoOfStaff": 12,
					"availableNoOfStaff": 10
				},
				{
					"sequence": 39,
					"minNoOfStaff": 9,
					"maxNoOfStaff": 11,
					"availableNoOfStaff": 10
				},
				{
					"sequence": 40,
					"minNoOfStaff": 10,
					"maxNoOfStaff": 12,
					"availableNoOfStaff": 11
				},
				{
					"sequence": 41,
					"minNoOfStaff": 10,
					"maxNoOfStaff": 12,
					"availableNoOfStaff": 11
				},
				{
					"sequence": 42,
					"minNoOfStaff": 9,
					"maxNoOfStaff": 12,
					"availableNoOfStaff": 11
				},
				{
					"sequence": 43,
					"minNoOfStaff": 9,
					"maxNoOfStaff": 12,
					"availableNoOfStaff": 11
				},
				{
					"sequence": 44,
					"minNoOfStaff": 11,
					"maxNoOfStaff": 13,
					"availableNoOfStaff": 12
				},
				{
					"sequence": 45,
					"minNoOfStaff": 11,
					"maxNoOfStaff": 12,
					"availableNoOfStaff": 10
				},
				{
					"sequence": 46,
					"minNoOfStaff": 11,
					"maxNoOfStaff": 13,
					"availableNoOfStaff": 10
				},
				{
					"sequence": 47,
					"minNoOfStaff": 11,
					"maxNoOfStaff": 13,
					"availableNoOfStaff": 12
				},
				{
					"sequence": 48,
					"minNoOfStaff": 9,
					"maxNoOfStaff": 15,
					"availableNoOfStaff": 10
				},
				{
					"sequence": 49,
					"minNoOfStaff": 9,
					"maxNoOfStaff": 15,
					"availableNoOfStaff": 11
				},
				{
					"sequence": 50,
					"minNoOfStaff": 9,
					"maxNoOfStaff": 15,
					"availableNoOfStaff": 12
				},
				{
					"sequence": 51,
					"minNoOfStaff": 9,
					"maxNoOfStaff": 15,
					"availableNoOfStaff": 13
				},
				{
					"sequence": 52,
					"minNoOfStaff": 7,
					"maxNoOfStaff": 10,
					"availableNoOfStaff": 8
				},
				{
					"sequence": 53,
					"minNoOfStaff": 7,
					"maxNoOfStaff": 10,
					"availableNoOfStaff": 8
				},
				{
					"sequence": 54,
					"minNoOfStaff": 7,
					"maxNoOfStaff": 10,
					"availableNoOfStaff": 10
				},
				{
					"sequence": 55,
					"minNoOfStaff": 7,
					"maxNoOfStaff": 10,
					"availableNoOfStaff": 10
				},
				{
					"sequence": 56,
					"minNoOfStaff": 8,
					"maxNoOfStaff": 11,
					"availableNoOfStaff": 6
				},
				{
					"sequence": 57,
					"minNoOfStaff": 8,
					"maxNoOfStaff": 11,
					"availableNoOfStaff": 6
				},
				{
					"sequence": 58,
					"minNoOfStaff": 8,
					"maxNoOfStaff": 11,
					"availableNoOfStaff": 5
				},
				{
					"sequence": 59,
					"minNoOfStaff": 9,
					"maxNoOfStaff": 11,
					"availableNoOfStaff": 5
				},
				{
					"sequence": 60,
					"minNoOfStaff": 10,
					"maxNoOfStaff": 15,
					"availableNoOfStaff": 10
				},
				{
					"sequence": 61,
					"minNoOfStaff": 10,
					"maxNoOfStaff": 15,
					"availableNoOfStaff": 10
				},
				{
					"sequence": 62,
					"minNoOfStaff": 10,
					"maxNoOfStaff": 14,
					"availableNoOfStaff": 10
				},
				{
					"sequence": 63,
					"minNoOfStaff": 10,
					"maxNoOfStaff": 14,
					"availableNoOfStaff": 10
				},
				{
					"sequence": 64,
					"minNoOfStaff": 9,
					"maxNoOfStaff": 13,
					"availableNoOfStaff": 12
				},
				{
					"sequence": 65,
					"minNoOfStaff": 9,
					"maxNoOfStaff": 13,
					"availableNoOfStaff": 12
				},
				{
					"sequence": 66,
					"minNoOfStaff": 9,
					"maxNoOfStaff": 13,
					"availableNoOfStaff": 13
				},
				{
					"sequence": 67,
					"minNoOfStaff": 9,
					"maxNoOfStaff": 13,
					"availableNoOfStaff": 13
				},
				{
					"sequence": 68,
					"minNoOfStaff": 11,
					"maxNoOfStaff": 12,
					"availableNoOfStaff": 12
				},
				{
					"sequence": 69,
					"minNoOfStaff": 11,
					"maxNoOfStaff": 12,
					"availableNoOfStaff": 12
				},
				{
					"sequence": 70,
					"minNoOfStaff": 11,
					"maxNoOfStaff": 12,
					"availableNoOfStaff": 12
				},
				{
					"sequence": 71,
					"minNoOfStaff": 11,
					"maxNoOfStaff": 12,
					"availableNoOfStaff": 12
				},
				{
					"sequence": 72,
					"minNoOfStaff": 12,
					"maxNoOfStaff": 14,
					"availableNoOfStaff": 11
				},
				{
					"sequence": 73,
					"minNoOfStaff": 12,
					"maxNoOfStaff": 14,
					"availableNoOfStaff": 11
				},
				{
					"sequence": 74,
					"minNoOfStaff": 12,
					"maxNoOfStaff": 14,
					"availableNoOfStaff": 13
				},
				{
					"sequence": 75,
					"minNoOfStaff": 9,
					"maxNoOfStaff": 14,
					"availableNoOfStaff": 13
				},
				{
					"sequence": 76,
					"minNoOfStaff": 10,
					"maxNoOfStaff": 12,
					"availableNoOfStaff": 14
				},
				{
					"sequence": 77,
					"minNoOfStaff": 10,
					"maxNoOfStaff": 12,
					"availableNoOfStaff": 14
				},
				{
					"sequence": 78,
					"minNoOfStaff": 10,
					"maxNoOfStaff": 12,
					"availableNoOfStaff": 13
				},
				{
					"sequence": 79,
					"minNoOfStaff": 5,
					"maxNoOfStaff": 12,
					"availableNoOfStaff": 14
				},
				{
					"sequence": 80,
					"minNoOfStaff": 5,
					"maxNoOfStaff": 9,
					"availableNoOfStaff": 4
				},
				{
					"sequence": 81,
					"minNoOfStaff": 6,
					"maxNoOfStaff": 9,
					"availableNoOfStaff": 4
				},
				{
					"sequence": 82,
					"minNoOfStaff": 6,
					"maxNoOfStaff": 9,
					"availableNoOfStaff": 4
				},
				{
					"sequence": 83,
					"minNoOfStaff": 4,
					"maxNoOfStaff": 9,
					"availableNoOfStaff": 4
				},
				{
					"sequence": 84,
					"minNoOfStaff": 6,
					"maxNoOfStaff": 8,
					"availableNoOfStaff": 6
				},
				{
					"sequence": 85,
					"minNoOfStaff": 4,
					"maxNoOfStaff": 8,
					"availableNoOfStaff": 7
				},
				{
					"sequence": 86,
					"minNoOfStaff": 4,
					"maxNoOfStaff": 8,
					"availableNoOfStaff": 6
				},
				{
					"sequence": 87,
					"minNoOfStaff": 7,
					"maxNoOfStaff": 8,
					"availableNoOfStaff": 7
				},
				{
					"sequence": 88,
					"minNoOfStaff": 7,
					"maxNoOfStaff": 9,
					"availableNoOfStaff": 10
				},
				{
					"sequence": 89,
					"minNoOfStaff": 7,
					"maxNoOfStaff": 9,
					"availableNoOfStaff": 10
				},
				{
					"sequence": 90,
					"minNoOfStaff": 7,
					"maxNoOfStaff": 9,
					"availableNoOfStaff": 14
				},
				{
					"sequence": 91,
					"minNoOfStaff": 10,
					"maxNoOfStaff": 9,
					"availableNoOfStaff": 14
				},
				{
					"sequence": 92,
					"minNoOfStaff": 10,
					"maxNoOfStaff": 12,
					"availableNoOfStaff": 11
				},
				{
					"sequence": 93,
					"minNoOfStaff": 10,
					"maxNoOfStaff": 12,
					"availableNoOfStaff": 12
				},
				{
					"sequence": 94,
					"minNoOfStaff": 10,
					"maxNoOfStaff": 12,
					"availableNoOfStaff": 12
				},
				{
					"sequence": 95,
					"minNoOfStaff": 10,
					"maxNoOfStaff": 12,
					"availableNoOfStaff": 12
				}
			]
		}

		var staffDataFromServer = { // to be removed upon server integration(Mock)		---- partial
			"phaseId": 1,
			"currentDay": 1507276403064,
			"typeOfDay": "abc",
			"weekCount": 20,
			"staffingLevelSetting": {
				"detailLevelMinutes": 15,
				"duration": {
					"from": {
						"hour": 13,
						"minute": 23,
						"second": 23,
						"nano": 63000000
					},
					"to": {
						"hour": 13,
						"minute": 23,
						"second": 23,
						"nano": 64000000
					}
				}
			},
			"staffingLevelInterval": [{
					"sequence": 3,
					"minNoOfStaff": 5,
					"maxNoOfStaff": 10,
					"availableNoOfStaff": 6,
					"staffingLevelActivities": [],
					"staffingLevelSkills": [],
					"staffingLevelDuration": {
						"from": {
							"hour": 7,
							"minute": 0,
							"second": 0,
							"nano": 0
						},
						"to": {
							"hour": 7,
							"minute": 15,
							"second": 0,
							"nano": 0
						}
					}
				},
				{
					"sequence": 1,
					"minNoOfStaff": 5,
					"maxNoOfStaff": 10,
					"availableNoOfStaff": 4,
					"staffingLevelActivities": [],
					"staffingLevelSkills": [],
					"staffingLevelDuration": {
						"from": {
							"hour": 7,
							"minute": 15,
							"second": 0,
							"nano": 0
						},
						"to": {
							"hour": 7,
							"minute": 30,
							"second": 0,
							"nano": 0
						}
					}
				}, {
					"sequence": 2,
					"minNoOfStaff": 5,
					"maxNoOfStaff": 10,
					"availableNoOfStaff": 5,
					"staffingLevelActivities": [],
					"staffingLevelSkills": [],
					"staffingLevelDuration": {
						"from": {
							"hour": 7,
							"minute": 30,
							"second": 0,
							"nano": 0
						},
						"to": {
							"hour": 7,
							"minute": 45,
							"second": 0,
							"nano": 0
						}
					}
				}, {
					"sequence": 0,
					"minNoOfStaff": 5,
					"maxNoOfStaff": 10,
					"availableNoOfStaff": 3,
					"staffingLevelActivities": [],
					"staffingLevelSkills": [],
					"staffingLevelDuration": {
						"from": {
							"hour": 7,
							"minute": 45,
							"second": 0,
							"nano": 0
						},
						"to": {
							"hour": 8,
							"minute": 0,
							"second": 0,
							"nano": 0
						}
					}
				},
				{
					"sequence": 0,
					"minNoOfStaff": 5,
					"maxNoOfStaff": 10,
					"availableNoOfStaff": 3,
					"staffingLevelActivities": [],
					"staffingLevelSkills": [],
					"staffingLevelDuration": {
						"from": {
							"hour": 8,
							"minute": 0,
							"second": 0,
							"nano": 0
						},
						"to": {
							"hour": 8,
							"minute": 15,
							"second": 0,
							"nano": 0
						}
					}
				},
				{
					"sequence": 1,
					"minNoOfStaff": 5,
					"maxNoOfStaff": 10,
					"availableNoOfStaff": 4,
					"staffingLevelActivities": [],
					"staffingLevelSkills": [],
					"staffingLevelDuration": {
						"from": {
							"hour": 8,
							"minute": 15,
							"second": 0,
							"nano": 0
						},
						"to": {
							"hour": 8,
							"minute": 30,
							"second": 0,
							"nano": 0
						}
					}
				}, {
					"sequence": 2,
					"minNoOfStaff": 5,
					"maxNoOfStaff": 10,
					"availableNoOfStaff": 5,
					"staffingLevelActivities": [],
					"staffingLevelSkills": [],
					"staffingLevelDuration": {
						"from": {
							"hour": 8,
							"minute": 30,
							"second": 0,
							"nano": 0
						},
						"to": {
							"hour": 8,
							"minute": 45,
							"second": 0,
							"nano": 0
						}
					}
				}, {
					"sequence": 0,
					"minNoOfStaff": 5,
					"maxNoOfStaff": 10,
					"availableNoOfStaff": 3,
					"staffingLevelActivities": [],
					"staffingLevelSkills": [],
					"staffingLevelDuration": {
						"from": {
							"hour": 8,
							"minute": 45,
							"second": 0,
							"nano": 0
						},
						"to": {
							"hour": 9,
							"minute": 0,
							"second": 0,
							"nano": 0
						}
					}
				}, {
					"sequence": 3,
					"minNoOfStaff": 5,
					"maxNoOfStaff": 10,
					"availableNoOfStaff": 6,
					"staffingLevelActivities": [],
					"staffingLevelSkills": [],
					"staffingLevelDuration": {
						"from": {
							"hour": 9,
							"minute": 0,
							"second": 0,
							"nano": 0
						},
						"to": {
							"hour": 9,
							"minute": 15,
							"second": 0,
							"nano": 0
						}
					}
				}, {
					"sequence": 1,
					"minNoOfStaff": 5,
					"maxNoOfStaff": 10,
					"availableNoOfStaff": 4,
					"staffingLevelActivities": [],
					"staffingLevelSkills": [],
					"staffingLevelDuration": {
						"from": {
							"hour": 9,
							"minute": 15,
							"second": 0,
							"nano": 0
						},
						"to": {
							"hour": 9,
							"minute": 30,
							"second": 0,
							"nano": 0
						}
					}
				}, {
					"sequence": 2,
					"minNoOfStaff": 5,
					"maxNoOfStaff": 10,
					"availableNoOfStaff": 5,
					"staffingLevelActivities": [],
					"staffingLevelSkills": [],
					"staffingLevelDuration": {
						"from": {
							"hour": 9,
							"minute": 30,
							"second": 0,
							"nano": 0
						},
						"to": {
							"hour": 9,
							"minute": 45,
							"second": 0,
							"nano": 0
						}
					}
				}, {
					"sequence": 0,
					"minNoOfStaff": 5,
					"maxNoOfStaff": 10,
					"availableNoOfStaff": 3,
					"staffingLevelActivities": [],
					"staffingLevelSkills": [],
					"staffingLevelDuration": {
						"from": {
							"hour": 9,
							"minute": 45,
							"second": 0,
							"nano": 0
						},
						"to": {
							"hour": 10,
							"minute": 0,
							"second": 0,
							"nano": 0
						}
					}
				}, {
					"sequence": 0,
					"minNoOfStaff": 5,
					"maxNoOfStaff": 10,
					"availableNoOfStaff": 3,
					"staffingLevelActivities": [],
					"staffingLevelSkills": [],
					"staffingLevelDuration": {
						"from": {
							"hour": 10,
							"minute": 0,
							"second": 0,
							"nano": 0
						},
						"to": {
							"hour": 10,
							"minute": 15,
							"second": 0,
							"nano": 0
						}
					}
				}, {
					"sequence": 1,
					"minNoOfStaff": 5,
					"maxNoOfStaff": 10,
					"availableNoOfStaff": 4,
					"staffingLevelActivities": [],
					"staffingLevelSkills": [],
					"staffingLevelDuration": {
						"from": {
							"hour": 10,
							"minute": 15,
							"second": 0,
							"nano": 0
						},
						"to": {
							"hour": 10,
							"minute": 30,
							"second": 0,
							"nano": 0
						}
					}
				}, {
					"sequence": 1,
					"minNoOfStaff": 5,
					"maxNoOfStaff": 10,
					"availableNoOfStaff": 4,
					"staffingLevelActivities": [],
					"staffingLevelSkills": [],
					"staffingLevelDuration": {
						"from": {
							"hour": 10,
							"minute": 30,
							"second": 0,
							"nano": 0
						},
						"to": {
							"hour": 10,
							"minute": 45,
							"second": 0,
							"nano": 0
						}
					}
				}, {
					"sequence": 1,
					"minNoOfStaff": 5,
					"maxNoOfStaff": 10,
					"availableNoOfStaff": 4,
					"staffingLevelActivities": [],
					"staffingLevelSkills": [],
					"staffingLevelDuration": {
						"from": {
							"hour": 10,
							"minute": 45,
							"second": 0,
							"nano": 0
						},
						"to": {
							"hour": 11,
							"minute": 0,
							"second": 0,
							"nano": 0
						}
					}
				}, {
					"sequence": 1,
					"minNoOfStaff": 5,
					"maxNoOfStaff": 10,
					"availableNoOfStaff": 4,
					"staffingLevelActivities": [],
					"staffingLevelSkills": [],
					"staffingLevelDuration": {
						"from": {
							"hour": 11,
							"minute": 0,
							"second": 0,
							"nano": 0
						},
						"to": {
							"hour": 11,
							"minute": 15,
							"second": 0,
							"nano": 0
						}
					}
				}, {
					"sequence": 1,
					"minNoOfStaff": 5,
					"maxNoOfStaff": 10,
					"availableNoOfStaff": 4,
					"staffingLevelActivities": [],
					"staffingLevelSkills": [],
					"staffingLevelDuration": {
						"from": {
							"hour": 11,
							"minute": 15,
							"second": 0,
							"nano": 0
						},
						"to": {
							"hour": 11,
							"minute": 30,
							"second": 0,
							"nano": 0
						}
					}
				}, {
					"sequence": 1,
					"minNoOfStaff": 5,
					"maxNoOfStaff": 10,
					"availableNoOfStaff": 4,
					"staffingLevelActivities": [],
					"staffingLevelSkills": [],
					"staffingLevelDuration": {
						"from": {
							"hour": 11,
							"minute": 30,
							"second": 0,
							"nano": 0
						},
						"to": {
							"hour": 11,
							"minute": 45,
							"second": 0,
							"nano": 0
						}
					}
				}, {
					"sequence": 1,
					"minNoOfStaff": 5,
					"maxNoOfStaff": 10,
					"availableNoOfStaff": 4,
					"staffingLevelActivities": [],
					"staffingLevelSkills": [],
					"staffingLevelDuration": {
						"from": {
							"hour": 11,
							"minute": 45,
							"second": 0,
							"nano": 0
						},
						"to": {
							"hour": 12,
							"minute": 0,
							"second": 0,
							"nano": 0
						}
					}
				}, {
					"sequence": 1,
					"minNoOfStaff": 5,
					"maxNoOfStaff": 10,
					"availableNoOfStaff": 4,
					"staffingLevelActivities": [],
					"staffingLevelSkills": [],
					"staffingLevelDuration": {
						"from": {
							"hour": 12,
							"minute": 0,
							"second": 0,
							"nano": 0
						},
						"to": {
							"hour": 12,
							"minute": 15,
							"second": 0,
							"nano": 0
						}
					}
				}, {
					"sequence": 1,
					"minNoOfStaff": 5,
					"maxNoOfStaff": 10,
					"availableNoOfStaff": 4,
					"staffingLevelActivities": [],
					"staffingLevelSkills": [],
					"staffingLevelDuration": {
						"from": {
							"hour": 12,
							"minute": 15,
							"second": 0,
							"nano": 0
						},
						"to": {
							"hour": 12,
							"minute": 30,
							"second": 0,
							"nano": 0
						}
					}
				}, {
					"sequence": 1,
					"minNoOfStaff": 5,
					"maxNoOfStaff": 10,
					"availableNoOfStaff": 4,
					"staffingLevelActivities": [],
					"staffingLevelSkills": [],
					"staffingLevelDuration": {
						"from": {
							"hour": 12,
							"minute": 30,
							"second": 0,
							"nano": 0
						},
						"to": {
							"hour": 12,
							"minute": 45,
							"second": 0,
							"nano": 0
						}
					}
				}, {
					"sequence": 1,
					"minNoOfStaff": 5,
					"maxNoOfStaff": 10,
					"availableNoOfStaff": 4,
					"staffingLevelActivities": [],
					"staffingLevelSkills": [],
					"staffingLevelDuration": {
						"from": {
							"hour": 12,
							"minute": 45,
							"second": 0,
							"nano": 0
						},
						"to": {
							"hour": 13,
							"minute": 0,
							"second": 0,
							"nano": 0
						}
					}
				}, {
					"sequence": 1,
					"minNoOfStaff": 5,
					"maxNoOfStaff": 10,
					"availableNoOfStaff": 4,
					"staffingLevelActivities": [],
					"staffingLevelSkills": [],
					"staffingLevelDuration": {
						"from": {
							"hour": 13,
							"minute": 0,
							"second": 0,
							"nano": 0
						},
						"to": {
							"hour": 13,
							"minute": 15,
							"second": 0,
							"nano": 0
						}
					}
				}, {
					"sequence": 1,
					"minNoOfStaff": 5,
					"maxNoOfStaff": 10,
					"availableNoOfStaff": 4,
					"staffingLevelActivities": [],
					"staffingLevelSkills": [],
					"staffingLevelDuration": {
						"from": {
							"hour": 13,
							"minute": 15,
							"second": 0,
							"nano": 0
						},
						"to": {
							"hour": 13,
							"minute": 30,
							"second": 0,
							"nano": 0
						}
					}
				}, {
					"sequence": 1,
					"minNoOfStaff": 5,
					"maxNoOfStaff": 10,
					"availableNoOfStaff": 4,
					"staffingLevelActivities": [],
					"staffingLevelSkills": [],
					"staffingLevelDuration": {
						"from": {
							"hour": 13,
							"minute": 30,
							"second": 0,
							"nano": 0
						},
						"to": {
							"hour": 13,
							"minute": 45,
							"second": 0,
							"nano": 0
						}
					}
				}, {
					"sequence": 1,
					"minNoOfStaff": 5,
					"maxNoOfStaff": 10,
					"availableNoOfStaff": 4,
					"staffingLevelActivities": [],
					"staffingLevelSkills": [],
					"staffingLevelDuration": {
						"from": {
							"hour": 13,
							"minute": 45,
							"second": 0,
							"nano": 0
						},
						"to": {
							"hour": 14,
							"minute": 0,
							"second": 0,
							"nano": 0
						}
					}
				}, {
					"sequence": 1,
					"minNoOfStaff": 5,
					"maxNoOfStaff": 10,
					"availableNoOfStaff": 4,
					"staffingLevelActivities": [],
					"staffingLevelSkills": [],
					"staffingLevelDuration": {
						"from": {
							"hour": 14,
							"minute": 0,
							"second": 0,
							"nano": 0
						},
						"to": {
							"hour": 14,
							"minute": 15,
							"second": 0,
							"nano": 0
						}
					}
				}, {
					"sequence": 1,
					"minNoOfStaff": 5,
					"maxNoOfStaff": 10,
					"availableNoOfStaff": 4,
					"staffingLevelActivities": [],
					"staffingLevelSkills": [],
					"staffingLevelDuration": {
						"from": {
							"hour": 14,
							"minute": 15,
							"second": 0,
							"nano": 0
						},
						"to": {
							"hour": 14,
							"minute": 30,
							"second": 0,
							"nano": 0
						}
					}
				}, {
					"sequence": 1,
					"minNoOfStaff": 5,
					"maxNoOfStaff": 10,
					"availableNoOfStaff": 4,
					"staffingLevelActivities": [],
					"staffingLevelSkills": [],
					"staffingLevelDuration": {
						"from": {
							"hour": 14,
							"minute": 30,
							"second": 0,
							"nano": 0
						},
						"to": {
							"hour": 14,
							"minute": 45,
							"second": 0,
							"nano": 0
						}
					}
				}, {
					"sequence": 1,
					"minNoOfStaff": 5,
					"maxNoOfStaff": 10,
					"availableNoOfStaff": 4,
					"staffingLevelActivities": [],
					"staffingLevelSkills": [],
					"staffingLevelDuration": {
						"from": {
							"hour": 14,
							"minute": 45,
							"second": 0,
							"nano": 0
						},
						"to": {
							"hour": 15,
							"minute": 0,
							"second": 0,
							"nano": 0
						}
					}
				}, {
					"sequence": 1,
					"minNoOfStaff": 5,
					"maxNoOfStaff": 10,
					"availableNoOfStaff": 4,
					"staffingLevelActivities": [],
					"staffingLevelSkills": [],
					"staffingLevelDuration": {
						"from": {
							"hour": 15,
							"minute": 0,
							"second": 0,
							"nano": 0
						},
						"to": {
							"hour": 15,
							"minute": 15,
							"second": 0,
							"nano": 0
						}
					}
				}, {
					"sequence": 1,
					"minNoOfStaff": 5,
					"maxNoOfStaff": 10,
					"availableNoOfStaff": 4,
					"staffingLevelActivities": [],
					"staffingLevelSkills": [],
					"staffingLevelDuration": {
						"from": {
							"hour": 15,
							"minute": 15,
							"second": 0,
							"nano": 0
						},
						"to": {
							"hour": 15,
							"minute": 30,
							"second": 0,
							"nano": 0
						}
					}
				}, {
					"sequence": 1,
					"minNoOfStaff": 5,
					"maxNoOfStaff": 10,
					"availableNoOfStaff": 4,
					"staffingLevelActivities": [],
					"staffingLevelSkills": [],
					"staffingLevelDuration": {
						"from": {
							"hour": 15,
							"minute": 30,
							"second": 0,
							"nano": 0
						},
						"to": {
							"hour": 15,
							"minute": 45,
							"second": 0,
							"nano": 0
						}
					}
				}, {
					"sequence": 1,
					"minNoOfStaff": 5,
					"maxNoOfStaff": 10,
					"availableNoOfStaff": 4,
					"staffingLevelActivities": [],
					"staffingLevelSkills": [],
					"staffingLevelDuration": {
						"from": {
							"hour": 15,
							"minute": 45,
							"second": 0,
							"nano": 0
						},
						"to": {
							"hour": 16,
							"minute": 0,
							"second": 0,
							"nano": 0
						}
					}
				}, {
					"sequence": 1,
					"minNoOfStaff": 5,
					"maxNoOfStaff": 10,
					"availableNoOfStaff": 4,
					"staffingLevelActivities": [],
					"staffingLevelSkills": [],
					"staffingLevelDuration": {
						"from": {
							"hour": 16,
							"minute": 0,
							"second": 0,
							"nano": 0
						},
						"to": {
							"hour": 16,
							"minute": 15,
							"second": 0,
							"nano": 0
						}
					}
				}, {
					"sequence": 1,
					"minNoOfStaff": 5,
					"maxNoOfStaff": 10,
					"availableNoOfStaff": 4,
					"staffingLevelActivities": [],
					"staffingLevelSkills": [],
					"staffingLevelDuration": {
						"from": {
							"hour": 16,
							"minute": 15,
							"second": 0,
							"nano": 0
						},
						"to": {
							"hour": 16,
							"minute": 30,
							"second": 0,
							"nano": 0
						}
					}
				}, {
					"sequence": 1,
					"minNoOfStaff": 5,
					"maxNoOfStaff": 10,
					"availableNoOfStaff": 4,
					"staffingLevelActivities": [],
					"staffingLevelSkills": [],
					"staffingLevelDuration": {
						"from": {
							"hour": 16,
							"minute": 30,
							"second": 0,
							"nano": 0
						},
						"to": {
							"hour": 16,
							"minute": 45,
							"second": 0,
							"nano": 0
						}
					}
				}, {
					"sequence": 1,
					"minNoOfStaff": 5,
					"maxNoOfStaff": 10,
					"availableNoOfStaff": 4,
					"staffingLevelActivities": [],
					"staffingLevelSkills": [],
					"staffingLevelDuration": {
						"from": {
							"hour": 16,
							"minute": 45,
							"second": 0,
							"nano": 0
						},
						"to": {
							"hour": 17,
							"minute": 0,
							"second": 0,
							"nano": 0
						}
					}
				}, {
					"sequence": 1,
					"minNoOfStaff": 5,
					"maxNoOfStaff": 10,
					"availableNoOfStaff": 4,
					"staffingLevelActivities": [],
					"staffingLevelSkills": [],
					"staffingLevelDuration": {
						"from": {
							"hour": 17,
							"minute": 0,
							"second": 0,
							"nano": 0
						},
						"to": {
							"hour": 17,
							"minute": 15,
							"second": 0,
							"nano": 0
						}
					}
				}, {
					"sequence": 1,
					"minNoOfStaff": 5,
					"maxNoOfStaff": 10,
					"availableNoOfStaff": 4,
					"staffingLevelActivities": [],
					"staffingLevelSkills": [],
					"staffingLevelDuration": {
						"from": {
							"hour": 17,
							"minute": 15,
							"second": 0,
							"nano": 0
						},
						"to": {
							"hour": 17,
							"minute": 30,
							"second": 0,
							"nano": 0
						}
					}
				}, {
					"sequence": 1,
					"minNoOfStaff": 5,
					"maxNoOfStaff": 10,
					"availableNoOfStaff": 4,
					"staffingLevelActivities": [],
					"staffingLevelSkills": [],
					"staffingLevelDuration": {
						"from": {
							"hour": 17,
							"minute": 30,
							"second": 0,
							"nano": 0
						},
						"to": {
							"hour": 17,
							"minute": 45,
							"second": 0,
							"nano": 0
						}
					}
				}, {
					"sequence": 1,
					"minNoOfStaff": 5,
					"maxNoOfStaff": 10,
					"availableNoOfStaff": 4,
					"staffingLevelActivities": [],
					"staffingLevelSkills": [],
					"staffingLevelDuration": {
						"from": {
							"hour": 17,
							"minute": 45,
							"second": 0,
							"nano": 0
						},
						"to": {
							"hour": 18,
							"minute": 0,
							"second": 0,
							"nano": 0
						}
					}
				}
			]
		}


		// all vars block
		{
			//common vars
			var today = new Date();
			var gameWidth = 1900;
			var gameHeight = 550;
			var xAxisRef = 60;
			var xAxisBarWidth = (gameWidth - xAxisRef) / 24 - 1; //each vertical bar width
			var yAxisScaleWidth = (gameHeight - 30) / 10;
			var shiftBarHeight = 20;
			var xScaleText = [];
			var yScaleTextPositive = [];
			var yScaleTextNegative = [];
			var yAxisRef = 385; //multiple of 10
			var scaleTextDistFromY = 25;
			var scaleTextDistFromX = 25;
			var underStaffPolygon = [];
			var overStaffPolygon = [];
			var underStaffGraphic = [];
			var overStaffGraphic = [];
			var xAxisScalePositions = [];
			var yAxisScalePositions = [];
			var polygonGroup;
			var positiveBounds;
			var negativeBounds;
			var loopCounter;
			var xAxis;
			var yAxis;
			var hourGranularity = 12; // must be 1, 2, 4 or 12 
			var staffLevelsHourGranularity; // must be 1, 2, or 4
			var levelBarWidth;
			var granularWidth = xAxisBarWidth / hourGranularity;
			var staffLevelsScale = 3;
			var yAxisScaleGranularWidth = yAxisScaleWidth / staffLevelsScale;

			//mockStaffLevels();

			// myShift vars
			var myShiftbars = [];
			var shiftBarLeftHandlers = [];
			var shiftBarRightHandlers = [];
			var shiftBarOnClickIntitialXPosition = {};
			var shiftHandlersWidth = 6;
			var minimumShiftLength = xAxisBarWidth / 4;
			var shiftBarNextDayHandler = [];
			var shiftBarPrevDayHandler = [];
			var activeShiftBarWidth;
			var shiftBarsGroup;

			// minRequiredLevels vars
			var minReqColor = 0x557d1d;
			var minReqHandlerStartYCoordinate;
			var minReqDragDist;
			var minRequiredBarHeight;
			var minRequiredBar = [];
			var minReqCenterHandler = [];
			var minReqLeftHandler = [];
			var minReqRightHandler = [];
			var minReqLeftLine = [];
			var minReqMiddleLine = [];
			var minReqLeftLineGraphic = [];
			var minReqMiddleLineGraphic = [];
			var minReqStaffLevelGroup;
			var minRequiredLevelsLength;

			// maxRequiredLevels vars
			var maxReqColor = 0xeea2b7;
			var maxReqHandlerStartYCoordinate;
			var maxReqDragDist;
			var maxRequiredBarHeight;
			var maxRequiredBar = [];
			var maxReqCenterHandler = [];
			var maxReqLeftHandler = [];
			var maxReqRightHandler = [];
			var maxReqLeftLine = [];
			var maxReqMiddleLine = [];
			var maxReqLeftLineGraphic = [];
			var maxReqMiddleLineGraphic = [];
			var maxReqStaffLevelGroup;
			var maxRequiredLevelsLength;
			// availableLevels vars
			var availColor = 0xcacacb;
			var availHandlerStartYCoordinate;
			var availDragDist;
			var availBarHeight;
			var availBar = [];
			var availCenterHandler = [];
			var availLeftHandler = [];
			var availRightHandler = [];
			var availLeftLine = [];
			var availMiddleLine = [];
			var availLeftLineGraphic = [];
			var availMiddleLineGraphic = [];
			var availStaffLevelGroup;
			var availableLevelsLength;

			// sickLevels vars
			var sickColor = 0xade1f7;
			var sickHandlerStartYCoordinate;
			var sickCenterHandlerId;
			var sickDragDist;
			var sickBarHeight;
			var sickBar = [];
			var sickCenterHandler = [];
			var sickLeftHandler = [];
			var sickRightHandler = [];
			var sickLeftLine = [];
			var sickMiddleLine = [];
			var sickLeftLineGraphic = [];
			var sickMiddleLineGraphic = [];
			var sickStaffLevelGroup;
			var sickLevelsLength = Object.keys(shiftData.sickLevels).length;
		}

		var currenrtDayShifts = [{ // to be removed upon server integration(Mock)
				"day": "Tue", // next day extended
				"date": new Date(),
				"dummy": false,
				"currentPhase": "Puzzle",
				"editable": true,
				"id": 21558,
				"startDate": dateFns.subDays(new Date(today.getFullYear(), today.getMonth(), today.getDate(), 19, 30), 0),
				"created": false,
				"endDate": dateFns.addDays(new Date(today.getFullYear(), today.getMonth(), today.getDate(), 2, 00), 1),
				"formattedActivityName": "Morning Day",
				"formattedStartDate": "",
				"formattedEndDate": "",
				"bId": "",
				"pId": "",
				"bonusTimeBank": "",
				"amount": "",
				"overStaff": "",
				"underStaff": "",
				"probability": "",
				"accumulatedTimeBank": "",
				"remarks": ""
			},
			{
				"day": "Tue", // prev day extended
				"date": new Date(),
				"dummy": true,
				"currentPhase": "Puzzle",
				"editable": false,
				"id": 2,
				"startDate": dateFns.subDays(new Date(today.getFullYear(), today.getMonth(), today.getDate(), 23, 00), 1),
				"created": false,
				"endDate": dateFns.addDays(new Date(today.getFullYear(), today.getMonth(), today.getDate(), 4, 00), 0),
				"formattedActivityName": "Morning Day",
				"formattedStartDate": "",
				"formattedEndDate": "",
				"bId": "",
				"pId": "",
				"bonusTimeBank": "",
				"amount": "",
				"overStaff": "",
				"underStaff": "",
				"probability": "",
				"accumulatedTimeBank": "",
				"remarks": ""
			},
			{
				"day": "Tue", // current day shift
				"date": new Date(),
				"dummy": false,
				"currentPhase": "Puzzle",
				"editable": true,
				"id": 4554,
				"startDate": dateFns.subDays(new Date(today.getFullYear(), today.getMonth(), today.getDate(), 6, 00), 0),
				"created": false,
				"endDate": dateFns.addDays(new Date(today.getFullYear(), today.getMonth(), today.getDate(), 8, 10), 0),
				"formattedActivityName": "Morning Day",
				"formattedStartDate": "",
				"formattedEndDate": "",
				"bId": "",
				"pId": "",
				"bonusTimeBank": "",
				"amount": "",
				"overStaff": "",
				"underStaff": "",
				"probability": "",
				"accumulatedTimeBank": "",
				"remarks": ""
			}
		];

		function mockStaffLevels(staffLevelsHourGranularity) { // no longer in use since using staffDataFromServer mockup
			// switch (staffLevelsHourGranularity) {

			// 	case 1:
			// 		{ //	0 ,1 ,2 ,3 ,4 ,5 ,6 ,7 ,8 ,9 ,10,11,12,13,14,15,16,17,18,19,20,21,22,23	
			// 			shiftData.availableLevels = [8, 4, 7, 10, 9, 9, 9, 7, 7, 7, 6, 4, 4, 8, 11, 15, 15, 15, 10, 10, 13, 8, 8, 13];

			// 			//  0 ,1 ,2 ,3 ,4 ,5 ,6 ,7 ,8 ,9 ,10,11,12,13,14,15,16,17,18,19,20,21,22,23	
			// 			shiftData.minRequiredLevels = [10, 5, 8, 10, 5, 5, 6, 8, 8, 9, 5, 12, 10, 8, 11, 13, 8, 7, 9, 9, 10, 7, 6, 10];

			// 			//	  0 ,1 ,2 ,3 ,4 ,5 ,6 ,7 ,8 ,9 ,10,11,12,13,14,15,16,17,18,19,20,21,22,23	
			// 			shiftData.maxRequiredLevels = [11, 10, 9, 11, 10, 9, 9, 10, 13, 11, 13, 13, 13, 10, 12, 14, 10, 15, 15, 11, 12,
			// 				10, 13, 13
			// 			];
			// 			break;
			// 		}
			// 	case 2:
			// 		{ //	0 ,1 ,2 ,3 ,4 ,5 ,6 ,7 ,8 ,9 ,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48	
			// 			shiftData.availableLevels = [8, 4, 7, 10, 9, 9, 9, 7, 7, 7, 6, 4, 4, 8, 11, 15, 15, 15, 10, 10, 13, 8, 8, 13, 8,
			// 				4, 7, 10, 9, 9, 9, 7, 7, 7, 6, 4, 4, 8, 11, 15, 15, 15, 10, 10, 13, 8, 8, 13
			// 			];

			// 			//  0 ,1 ,2 ,3 ,4 ,5 ,6 ,7 ,8 ,9 ,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48	
			// 			shiftData.minRequiredLevels = [10, 5, 8, 10, 5, 5, 6, 8, 8, 9, 5, 12, 10, 8, 11, 13, 8, 7, 9, 9, 10, 7, 6, 10,
			// 				10,
			// 				5, 8, 10, 5, 5, 6, 8, 8, 9, 5, 12, 10, 8, 11, 13, 8, 7, 9, 9, 10, 7, 6, 10
			// 			];

			// 			//	  0 ,1 ,2 ,3 ,4 ,5 ,6 ,7 ,8 ,9 ,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48	
			// 			shiftData.maxRequiredLevels = [11, 10, 9, 11, 10, 9, 9, 10, 13, 11, 13, 13, 13, 10, 12, 14, 10, 15, 15, 11, 12,
			// 				10, 13, 13, 11, 10, 9, 11, 10, 9, 9, 10, 13, 11, 13, 13, 13, 10, 12, 14, 10, 15, 15, 11, 12, 10, 13, 13
			// 			];
			// 			break;
			// 		}
			// 	case 4:
			// 		{
			// 			// 0 ,1 ,2 ,3 ,4 ,5 ,6 ,7 ,8 ,9 ,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,	
			// 			shiftData.availableLevels = [5, 6, 6, 5, 9, 9, 10, 9, 10, 10, 10, 10, 9, 9, 9, 12, 11, 11, 11, 10, 13, 12, 12,
			// 				12, 13,
			// 				// 25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,
			// 				13, 13, 13, 6, 6, 6, 6, 9, 9, 9, 9, 12, 12, 10, 10, 11, 11, 11, 11, 12, 10, 10, 12, 10, 11, 12, 13, 8, 8, 10,
			// 				10, 6, 6, 5,
			// 				// 59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,	
			// 				5, 10, 10, 10, 10, 12, 12, 13, 13, 12, 12, 12, 12, 11, 11, 13, 13, 14, 14, 13, 14, 4, 4, 4, 4, 6, 7, 6, 7, 10,
			// 				10, 14, 14, 11,
			// 				// 93,94,95
			// 				12, 12, 12
			// 			];

			// 			// 0 ,1 ,2 ,3 ,4 ,5 ,6 ,7 ,8 ,9 ,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,	
			// 			shiftData.minRequiredLevels = [10, 10, 10, 10, 8, 8, 8, 8, 7, 7, 7, 7, 11, 11, 11, 11, 9, 9, 9, 9, 10, 10, 10,
			// 				10, 12,
			// 				// 25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,
			// 				12, 12, 12, 7, 7, 7, 7, 8, 9, 8, 8, 9, 9, 9, 9, 10, 10, 9, 9, 11, 11, 11, 11, 9, 9, 9, 9, 7, 7, 7, 7, 8, 8, 8,
			// 				// 59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,	
			// 				9, 10, 10, 10, 10, 9, 9, 9, 9, 11, 11, 11, 11, 12, 12, 12, 9, 10, 10, 10, 5, 5, 6, 6, 4, 6, 4, 4, 7, 7, 7, 7,
			// 				10, 10,
			// 				// 93,94,95
			// 				10, 10, 10
			// 			];

			// 			// 0 ,1 ,2 ,3 ,4 ,5 ,6 ,7 ,8 ,9 ,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,	
			// 			shiftData.maxRequiredLevels = [12, 12, 12, 12, 10, 10, 10, 10, 13, 13, 13, 13, 12, 12, 13, 13, 14, 14, 14, 14,
			// 				11, 11, 11, 11, 14,
			// 				// 25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,
			// 				14, 14, 14, 9, 9, 9, 9, 10, 10, 10, 10, 11, 11, 12, 11, 12, 12, 12, 12, 13, 12, 13, 13, 15, 15, 15, 15, 10, 10,
			// 				10, 10, 11, 11, 11,
			// 				// 59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,
			// 				11, 15, 15, 14, 14, 13, 13, 13, 13, 12, 12, 12, 12, 14, 14, 14, 14, 12, 12, 12, 12, 9, 9, 9, 9, 8, 8, 8, 8, 9,
			// 				9, 9, 9, 12,
			// 				// 93,94,95
			// 				12, 12, 12
			// 			];
			// 		}
			// 	default:
			// 		{
			// 			return 0;
			// 		}
			// }
		}

		function mockStaffLevelsToZero(staffLevelsHourGranularity) { // no longer in use since using staffDataFromServer mockup
			switch (staffLevelsHourGranularity) {

				case 1:
					{
						shiftData.availableLevels = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
						shiftData.minRequiredLevels = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
						shiftData.maxRequiredLevels = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
						break;
					}
				case 2:
					{
						shiftData.availableLevels = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
							0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
						];
						shiftData.minRequiredLevels = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
							0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
						];
						shiftData.maxRequiredLevels = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
							0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
						];
						break;
					}
				case 4:
					{
						shiftData.availableLevels = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
							0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
							0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
						];
						shiftData.minRequiredLevels = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
							0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
							0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
						];
						shiftData.maxRequiredLevels = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
							0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
							0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
						];
						break;
					}
				default:
					{
						return 0;
					}
			}
		}


		preparePhaserStaffLevels(staffDataFromServer);
		preparePhaserShiftData(currenrtDayShifts);

		function preparePhaserShiftData(currenrtDayShifts) {
			shiftData.myShift = [];
			// converting minutes given into index, to be used for comparison in xScalePositions array while shift bar creation.
			if (currenrtDayShifts.length > 0) {

				currenrtDayShifts.forEach((currenrtDayShift) => {
					checkForExtendedShift(currenrtDayShift);
					let isEditable = currenrtDayShift.editable;
					shiftData.myShift.push({
						id: currenrtDayShift.id,
						startTime: {
							hour: currenrtDayShift.shiftStartHour,
							minutes: currenrtDayShift.shiftStartMinutes
						},
						endTime: {
							hour: currenrtDayShift.shiftEndHour,
							minutes: currenrtDayShift.shiftEndMinutes
						},
						startDateObj: currenrtDayShift.startDate,
						endDateObj: currenrtDayShift.endDate,
						editable: isEditable,
						exitsNextDay: currenrtDayShift.exitsNextDay,
						exitsPrevDay: currenrtDayShift.exitsPrevDay,
						nextDayTimeOffset: currenrtDayShift.nextDayTimeOffset,
						prevDayTimeOffset: currenrtDayShift.prevDayTimeOffset,
					});
				});
				console.log("shiftData", shiftData)
			}
		}

		function preparePhaserStaffLevels(currentDayStaffData) {
			staffLevelsHourGranularity = getHourGranularityFromMinutes(currentDayStaffData.staffingLevelSetting.detailLevelMinutes);
			mockStaffLevelsToZero(staffLevelsHourGranularity);

			if (currentDayStaffData && currentDayStaffData.staffingLevelInterval) {
				//console.log("currentDayStaffData.staffingLevelInterval", currentDayStaffData.staffingLevelInterval)
				currentDayStaffData.staffingLevelInterval.forEach((levelsObj) => {
					levelsObj.phaserSequence = addPhaserSequence(staffLevelsHourGranularity, levelsObj.staffingLevelDuration)
					shiftData.availableLevels[levelsObj.phaserSequence] = levelsObj.availableNoOfStaff;
					shiftData.minRequiredLevels[levelsObj.phaserSequence] = levelsObj.minNoOfStaff;
					shiftData.maxRequiredLevels[levelsObj.phaserSequence] = levelsObj.maxNoOfStaff;
				});
			} else {
				shiftData.availableLevels = [];
				shiftData.minRequiredLevels = [];
				shiftData.maxRequiredLevels = [];
			}
			availableLevelsLength = shiftData.availableLevels.length;
			minRequiredLevelsLength = shiftData.minRequiredLevels.length;
			maxRequiredLevelsLength = shiftData.maxRequiredLevels.length;
			levelBarWidth = xAxisBarWidth / staffLevelsHourGranularity;
		}

		function addPhaserSequence(staffLevelsHourGranularity, staffingLevelDuration) {
			let staffLevelsHourGranularityInMinutes = 60 / staffLevelsHourGranularity;
			return (staffLevelsHourGranularity * staffingLevelDuration.from.hour) + (staffingLevelDuration.from.minute /
				staffLevelsHourGranularityInMinutes)
		}

		function getHourGranularityFromMinutes(minutes) {
			switch (minutes) {
				case 60:
					return 1;
				case 30:
					return 2;
				case 15:
					return 4;
				case 5:
					return 12;
				default:
					return 1;
			}
		}

		function checkForExtendedShift(currenrtDayShift) {
			let startDate = _.cloneDeep(currenrtDayShift.startDate);
			let endDate = _.cloneDeep(currenrtDayShift.endDate);
			let currentDate = _.cloneDeep(currenrtDayShift.date);
			startDate.setHours(0, 0, 0, 0);
			endDate.setHours(0, 0, 0, 0);
			currentDate.setHours(0, 0, 0, 0);

			if (dateFns.isAfter(endDate, currentDate) && dateFns.differenceInMinutes(currenrtDayShift.endDate, endDate) != 0) {

				currenrtDayShift.exitsNextDay = true;
				currenrtDayShift.exitsPrevDay = false;
				currenrtDayShift.nextDayTimeOffset = {
					hour: dateFns.getHours(currenrtDayShift.endDate),
					minutes: dateFns.getMinutes(currenrtDayShift.endDate)
				}
				currenrtDayShift.prevDayTimeOffset = null;
				//currenrtDayShift.endDate.setHours(0, 0, 0, 0);
				currenrtDayShift.shiftStartHour = dateFns.getHours(currenrtDayShift.startDate);
				currenrtDayShift.shiftEndHour = 24;
				currenrtDayShift.shiftStartMinutes = replaceMinutesInMinuteIndex(dateFns.getMinutes(currenrtDayShift.startDate));
				currenrtDayShift.shiftEndMinutes = 0;

			} else if (dateFns.isBefore(startDate, currentDate)) {

				currenrtDayShift.exitsNextDay = false;
				currenrtDayShift.exitsPrevDay = true;
				currenrtDayShift.nextDayTimeOffset = null;
				currenrtDayShift.prevDayTimeOffset = {
					hour: dateFns.getHours(currenrtDayShift.startDate),
					minutes: dateFns.getMinutes(currenrtDayShift.startDate)
				}
				//currenrtDayShift.startDate.setHours(24, 0, 0, 0)
				currenrtDayShift.shiftStartHour = 0
				if (dateFns.differenceInMinutes(currenrtDayShift.endDate, endDate) == 0) {
					currenrtDayShift.shiftEndHour = 24;
				} else {
					currenrtDayShift.shiftEndHour = dateFns.getHours(currenrtDayShift.endDate);
				}
				currenrtDayShift.shiftStartMinutes = 0
				currenrtDayShift.shiftEndMinutes = replaceMinutesInMinuteIndex(dateFns.getMinutes(currenrtDayShift.endDate));

			} else {

				currenrtDayShift.exitsNextDay = false;
				currenrtDayShift.exitsPrevDay = false;
				currenrtDayShift.nextDayTimeOffset = null;
				currenrtDayShift.prevDayTimeOffset = null;
				currenrtDayShift.shiftStartHour = dateFns.getHours(currenrtDayShift.startDate);
				currenrtDayShift.shiftEndHour = dateFns.getHours(currenrtDayShift.endDate);
				currenrtDayShift.shiftStartMinutes = replaceMinutesInMinuteIndex(dateFns.getMinutes(currenrtDayShift.startDate));
				currenrtDayShift.shiftEndMinutes = replaceMinutesInMinuteIndex(dateFns.getMinutes(currenrtDayShift.endDate));
			}
		}

		function replaceMinutesInMinuteIndex(minutes) {
			minutes = floorTheMinutes(minutes, floorRefObj[hourGranularity]);
			return minutesInMinuteIndexObj[hourGranularity][minutes];
		}

		function floorTheMinutes(minutes, roundTo) {
			if (minutes < roundTo || roundTo == 0) {
				return 0;
			}
			return Math.floor(minutes / roundTo) * roundTo;
		}

		var game = new Phaser.Game(gameWidth, gameHeight, Phaser.AUTO, 'graph-chart-container-section', {
			preload: preload,
			create: create,
			update: update,
			render: render
		});

		function preload() {
			game.load.image('greyImage', './assets/greyImage.jpg');
			game.load.image('transparent', './assets/transparent.png');
			game.load.image('node', './assets/circle_blue.png');
			game.load.image('sky', './assets/sky.png');
			game.load.image('shiftImage', './assets/shiftImage.png');
			game.load.image('leftArrow', './assets/leftArrow.png');
			game.load.image('rightArrow', './assets/rightArrow.png');
			game.forceSingleUpdate = true;

		}

		function create() {
			console.log("granularWidth", granularWidth)
			game.stage.backgroundColor = '#ffffff';
			positiveBounds = new Phaser.Rectangle(xAxisRef, parseInt('00', 10), 24 * xAxisBarWidth, yAxisRef + 7);
			negativeBounds = new Phaser.Rectangle(xAxisRef, yAxisRef - 4, 24 * xAxisBarWidth + 10, yAxisRef - shiftBarHeight);


			loopCounter = 1;
			availStaffLevelGroup = game.add.group();
			// loop to iterate over available staff levels for each hour
			for (var eachHour in shiftData.availableLevels) {
				createStaffLevelsBar(shiftData.availableLevels[loopCounter - 1], loopCounter, availableLevelsLength, "greyImage",
					availBar, availCenterHandler, "availBar", availRightHandler, availLeftHandler, availLeftLine, availMiddleLine,
					availLeftLineGraphic, availMiddleLineGraphic, availStaffLevelGroup, availHandlerDragStart,
					availHandlerDragUpdate, availHandlerDragStop, availColor)
				loopCounter++;
			}

			loopCounter = 1;
			minReqStaffLevelGroup = game.add.group();
			// loop to iterate over minRequired staff levels for each hour
			for (var eachHour in shiftData.minRequiredLevels) {
				createStaffLevelsBar(shiftData.minRequiredLevels[loopCounter - 1], loopCounter, minRequiredLevelsLength,
					"transparent", minRequiredBar, minReqCenterHandler, "minReqBar", minReqRightHandler, minReqLeftHandler,
					minReqLeftLine, minReqMiddleLine,
					minReqLeftLineGraphic, minReqMiddleLineGraphic, minReqStaffLevelGroup, minReqHandlerDragStart,
					minReqHandlerDragUpdate, minReqHandlerDragStop, minReqColor)
				loopCounter++;
			}

			loopCounter = 1;
			maxReqStaffLevelGroup = game.add.group();
			// loop to iterate over maxRequired staff levels for each hour
			for (var eachHour in shiftData.maxRequiredLevels) {
				createStaffLevelsBar(shiftData.maxRequiredLevels[loopCounter - 1], loopCounter, maxRequiredLevelsLength,
					"transparent", maxRequiredBar, maxReqCenterHandler, "maxReqBar", maxReqRightHandler, maxReqLeftHandler,
					maxReqLeftLine, maxReqMiddleLine,
					maxReqLeftLineGraphic, maxReqMiddleLineGraphic, maxReqStaffLevelGroup, maxReqHandlerDragStart,
					maxReqHandlerDragUpdate, maxReqHandlerDragStop, maxReqColor)
				loopCounter++;
			}

			polygonGroup = game.add.group();
			shiftBarsGroup = game.add.group();
			createScale();
			indicateConflictAreas();
			createMyShiftBar(shiftData.myShift);
			createButtons();
		}

		function createMyShiftBar(myShiftData) {
			let counter = 1;
			myShiftData.forEach((shift) => {
				myShiftbars[counter] = game.add.sprite(xAxisRef + ((shift.startTime.hour) * xAxisBarWidth) + ((shift.startTime.minutes) *
						granularWidth), yAxisRef - shiftBarHeight -
					11, 'shiftImage');

				if (shift.editable && !shift.exitsPrevDay) {
					myShiftbars[counter].inputEnabled = true;
				}
				myShiftbars[counter].width = ((shift.endTime.hour - shift.startTime.hour) * xAxisBarWidth) + ((shift.endTime.minutes) *
					granularWidth) - ((shift.startTime.minutes) * granularWidth);
				myShiftbars[counter].height = shiftBarHeight + 10;
				myShiftbars[counter].shiftId = shift.id;
				myShiftbars[counter].counterVal = counter;
				myShiftbars[counter].startDateObj = shift.startDateObj;
				myShiftbars[counter].endDateObj = shift.endDateObj;
				myShiftbars[counter].exitsNextDay = shift.exitsNextDay;
				myShiftbars[counter].exitsPrevDay = shift.exitsPrevDay;
				myShiftbars[counter].alpha = 0.8;
				if (myShiftbars[counter].inputEnabled) {
					myShiftbars[counter].input.allowVerticalDrag = false;
					myShiftbars[counter].input.enableDrag(false, false);
					myShiftbars[counter].input.boundsRect = positiveBounds;
					myShiftbars[counter].events.onDragStart.add(shiftBarDragStart);
					myShiftbars[counter].events.onDragUpdate.add(shiftBarDragUpdate);
					myShiftbars[counter].events.onDragStop.add(shiftBarDragStop);
				}

				// creating and aligning the handler to the shift bar sprite
				if (shift.editable) {

					shiftBarLeftHandlers[counter] = game.add.sprite(myShiftbars[counter].x, myShiftbars[counter].centerY,
						'sky');
					shiftBarLeftHandlers[counter].counterVal = counter;
					shiftBarLeftHandlers[counter].handlerType = "left";
					if (shift.exitsNextDay) {
						shiftBarLeftHandlers[counter].anchor.set(0.5, 0.5);
					} else {
						shiftBarLeftHandlers[counter].anchor.set(0, 0.5);
					}
					shiftBarLeftHandlers[counter].visible = true;
					shiftBarLeftHandlers[counter].width = shiftHandlersWidth;
					shiftBarLeftHandlers[counter].height = myShiftbars[counter].height;
					if (!shift.exitsPrevDay) {
						shiftBarLeftHandlers[counter].inputEnabled = true;
						shiftBarLeftHandlers[counter].input.allowVerticalDrag = false;
						shiftBarLeftHandlers[counter].input.enableDrag(false, true);
						shiftBarLeftHandlers[counter].input.useHandCursor = true;
						shiftBarLeftHandlers[counter].input.boundsRect = positiveBounds;
					}
					//shiftBarLeftHandlers.events.onDragStart.add(leftShiftHandleDragStart);
					shiftBarLeftHandlers[counter].events.onDragStart.add(shiftHandleDragStart);
					shiftBarLeftHandlers[counter].events.onDragUpdate.add(shiftHandleDragUpdate);
					shiftBarLeftHandlers[counter].events.onDragStop.add(shiftHandleDragStop);

					// creating and aligning the handler to the shift bar sprite
					shiftBarRightHandlers[counter] = game.add.sprite(myShiftbars[counter].right, myShiftbars[counter].centerY,
						'sky');
					shiftBarRightHandlers[counter].counterVal = counter;
					shiftBarRightHandlers[counter].handlerType = "right";
					shiftBarRightHandlers[counter].anchor.set(1, 0.5);
					shiftBarRightHandlers[counter].visible = true;
					shiftBarRightHandlers[counter].width = shiftHandlersWidth;
					shiftBarRightHandlers[counter].height = myShiftbars[counter].height;
					if (!shift.exitsNextDay) {
						shiftBarRightHandlers[counter].inputEnabled = true;
						shiftBarRightHandlers[counter].input.allowVerticalDrag = false;
						shiftBarRightHandlers[counter].input.enableDrag(false, true);
						shiftBarRightHandlers[counter].input.useHandCursor = true;
						shiftBarRightHandlers[counter].input.boundsRect = positiveBounds;
					}
					//shiftBarRightHandlers.events.onDragStart.add(rightShiftHandleDragStart);
					shiftBarRightHandlers[counter].events.onDragStart.add(shiftHandleDragStart);
					shiftBarRightHandlers[counter].events.onDragUpdate.add(shiftHandleDragUpdate);
					shiftBarRightHandlers[counter].events.onDragStop.add(shiftHandleDragStop);
				}

				if (shift.exitsNextDay) {
					shiftBarNextDayHandler[counter] = game.add.sprite(myShiftbars[counter].right, myShiftbars[counter].centerY,
						'rightArrow');
					shiftBarNextDayHandler[counter].anchor.set(0, 0.5);
					myShiftbars[counter].inverseNextDayTimeOffset = getInverseTimeIndexes(shift.startDateObj, shift.endDateObj,
						"nextDay")
					myShiftbars[counter].inverseNextDayXCoordinate = getXScaleCoordinatesFromIndex(myShiftbars[counter].inverseNextDayTimeOffset);
					myShiftbars[counter].variableEndDateObj = _.cloneDeep(myShiftbars[counter].endDateObj);
					let variableEndDateTimeObj = getVariableDateObjTime(myShiftbars[counter].variableEndDateObj, "nextDay");
					let nextText = variableEndDateTimeObj.hour + "." + variableEndDateTimeObj.minutes + " hours - Extended";
					myShiftbars[counter].nextOffsetText = game.add.text(myShiftbars[counter].right - 5, myShiftbars[counter].y -
						10,
						nextText, {
							font: "18px open"
						});
					myShiftbars[counter].nextOffsetText.anchor.setTo(1, 0.5);
					shiftBarsGroup.add(myShiftbars[counter].nextOffsetText);
				} else if (shift.exitsPrevDay) {
					shiftBarPrevDayHandler[counter] = game.add.sprite(myShiftbars[counter].x, myShiftbars[counter].centerY,
						'leftArrow');
					shiftBarPrevDayHandler[counter].anchor.set(1, 0.5);
					myShiftbars[counter].inversePrevDayTimeOffset = getInverseTimeIndexes(shift.startDateObj, shift.endDateObj,
						"prevDay")
					myShiftbars[counter].inversePrevDayXCoordinate = getXScaleCoordinatesFromIndex(myShiftbars[counter].inversePrevDayTimeOffset);
					myShiftbars[counter].variableStartDateObj = _.cloneDeep(myShiftbars[counter].startDateObj);
					let variableStartDateTimeObj = getVariableDateObjTime(myShiftbars[counter].variableStartDateObj, "prevDay");
					let prevText = variableStartDateTimeObj.hour + "." + variableStartDateTimeObj.minutes + " hours - Extended";
					myShiftbars[counter].prevOffsetText = game.add.text(myShiftbars[counter].x + 5, myShiftbars[counter].y - 10,
						prevText, {
							font: "18px open"
						});
					myShiftbars[counter].prevOffsetText.anchor.setTo(0, 0.5);
					shiftBarsGroup.add(myShiftbars[counter].prevOffsetText);
				}

				shiftBarsGroup.add(myShiftbars[counter]);
				if (shift.editable) {
					shiftBarsGroup.add(shiftBarLeftHandlers[counter]);
					shiftBarsGroup.add(shiftBarRightHandlers[counter]);
				}

				counter++;
			});
		}

		function getInverseTimeIndexes(shiftStartDateObj, shiftEndDateObj, scenario) {
			let hour;
			let minutes;
			if (scenario == "nextDay") {
				let clonedShiftStartDateObj = _.cloneDeep(shiftStartDateObj);
				clonedShiftStartDateObj.setHours(
					shiftStartDateObj.getHours() - shiftEndDateObj.getHours(),
					shiftStartDateObj.getMinutes() - shiftEndDateObj.getMinutes(),
				)
				//console.log("clonedShiftStartDateObj", clonedShiftStartDateObj);
				hour = clonedShiftStartDateObj.getHours();
				minutes = clonedShiftStartDateObj.getMinutes();
				let hourIndex = hour;
				let minutesIndex = replaceMinutesInMinuteIndex(minutes);
				//console.log("hourIndex, minutesIndex", hourIndex, minutesIndex)
				return {
					hourIndex,
					minutesIndex
				};
			} else if (scenario == "prevDay") {
				let clonedShiftEndDateObj = _.cloneDeep(shiftEndDateObj);
				clonedShiftEndDateObj.setHours(
					shiftEndDateObj.getHours() + shiftStartDateObj.getHours(),
					shiftEndDateObj.getMinutes() + shiftStartDateObj.getMinutes(),
				)
				//console.log("clonedShiftEndDateObj", clonedShiftEndDateObj);
				hour = clonedShiftEndDateObj.getHours();
				minutes = clonedShiftEndDateObj.getMinutes();
				let hourIndex = hour;
				let minutesIndex = replaceMinutesInMinuteIndex(minutes);
				//console.log("hourIndex, minutesIndex", hourIndex, minutesIndex)
				return {
					hourIndex,
					minutesIndex
				};
			}
		}

		function getXScaleCoordinatesFromIndex(timeIndexObj) {
			// console.log("xAxisScalePositions", xAxisScalePositions);
			// console.log("timeIndexObj", timeIndexObj);
			let hourIndex = timeIndexObj.hourIndex;
			let minutesIndex = timeIndexObj.minutesIndex;
			//console.log(xAxisScalePositions[hourIndex][minutesIndex]);
			return xAxisScalePositions[hourIndex][minutesIndex];
		}

		function shiftBarDragStart(shift, pointer, x, y) {
			console.log("inside shiftBarDragStart ")
			shiftBarOnClickIntitialXPosition = {
				x: shift.x,
				right: shift.right
			}
			activeShiftBarWidth = shift.width;
		}

		function shiftBarDragUpdate(shiftBar, pointer, newX, newY, snapOnDrag, fromStart) {
			if (shiftBar.exitsNextDay || shiftBar.exitsPrevDay) {
				updateShiftWidthOnDrag(shiftBar, newX);
			}
			updateShiftHandlerPosition(shiftBar);
		}

		function shiftBarDragStop(shiftBar, pointer, x, y) {
			let shiftBarX = shiftBar.x
			repositionSpriteBasedOnXGranularity(shiftBar);
			updateShiftHandlerPosition(shiftBar);
			emitPosition(shiftBar, "drag");
			//console.log("xAxisScalePositions", xAxisScalePositions);
		}



		function updateShiftWidthOnDrag(shiftBar, newX) {

			/**** - Phaser Bug WorkAround - ********************************
				* On Some Occasions shiftBarDragStart function is not called 
					automatically on click
			***************************************************************/
			if (!activeShiftBarWidth) {
				shiftBarDragStart(shiftBar, {}, 10, 20); //dummy values
			}
			/*******************************************/


			let dragDistance = shiftBarOnClickIntitialXPosition.x - newX;
			if (!isNaN(dragDistance)) {
				//console.log("dragDistance", dragDistance);
				if (shiftBar.exitsNextDay) {
					let endCoordinates = getXScaleCoordinatesFromIndex({
						hourIndex: 24,
						minutesIndex: 0
					});

					shiftBar.width = activeShiftBarWidth + dragDistance;
					shiftBar.right = endCoordinates;
					if (shiftBar.width < granularWidth) { // to prevent dragging a shift to another day
						shiftBar.width = granularWidth;
						shiftBar.x = endCoordinates - granularWidth;
					}
					//console.log("shiftBar.right, shiftBar.x", shiftBar.right,shiftBar.x )
					if (newX < shiftBar.inverseNextDayXCoordinate) {
						let counter = shiftBar.counterVal;
						shiftBar.exitsNextDay = false;
						shiftBar.width = endCoordinates - shiftBar.inverseNextDayXCoordinate
						shiftBarNextDayHandler[counter].visible = false;
						shiftBarLeftHandlers[counter].anchor.set(0, 0.5);
						shiftBarRightHandlers[counter].inputEnabled = true;
						shiftBarRightHandlers[counter].input.allowVerticalDrag = false;
						shiftBarRightHandlers[counter].input.enableDrag(false, true);
						shiftBarRightHandlers[counter].input.useHandCursor = true;
						shiftBarRightHandlers[counter].input.boundsRect = positiveBounds;
						myShiftbars[counter].endDateObj = dateFns.subDays(myShiftbars[counter].endDateObj, 1);
						myShiftbars[counter].nextOffsetText.destroy();
					}

				} else if (shiftBar.exitsNextDay) {

				} else {}
			}

		}

		function updateShiftHandlerPosition(shiftBar) {
			let counter = shiftBar.counterVal;
			shiftBarLeftHandlers[counter].x = shiftBar.x
			shiftBarLeftHandlers[counter].y = shiftBar.centerY
			shiftBarRightHandlers[counter].x = shiftBar.right
			shiftBarRightHandlers[counter].y = shiftBar.centerY
		}



		function shiftHandleDragStart(handler, pointer, x, y) {
			let handlerType = handler.handlerType;
			let counter = handler.counterVal;
			shiftBarOnClickIntitialXPosition = {
				x: myShiftbars[counter].x,
				right: myShiftbars[counter].right
			}
		}

		function shiftHandleDragUpdate(handler, pointer, x, y, snapOnDrag, fromStart) {
			let handlerType = handler.handlerType;
			updateShiftBarPosition(handler, handlerType);
		}

		function shiftHandleDragStop(handler, pointer, x, y) {
			let handlerType = handler.handlerType;
			let handlerX = handler.x
			repositionSpriteBasedOnXGranularity(handler);
			updateShiftBarPosition(handler, handlerType);
			emitPosition(handler, "stretch");
		}

		function repositionSpriteBasedOnXGranularity(sprite) {
			console.log("in repositionSpriteBasedOnXGranularity", sprite.x, sprite.right);
			console.log("xAxisScalePositions", xAxisScalePositions)
			let spriteX = sprite.x
			let innerUpdatedFlag = false;
			let floorDifference;
			xAxisScalePositions.forEach(function (xPositionArr, parentIndex) {
				if ((spriteX > xAxisScalePositions[parentIndex][0] && xAxisScalePositions[parentIndex + 1] && spriteX <
						xAxisScalePositions[parentIndex + 1][0]) || spriteX ==
					xAxisScalePositions[parentIndex][0]) {
					console.log("parent Index", parentIndex);
					xPositionArr.forEach(function (xPosition, index) {
						if (parseFloat(spriteX.toFixed(6)) > parseFloat(xPositionArr[index].toFixed(6)) && xPositionArr[index + 1] &&
							parseFloat(spriteX.toFixed(6)) < parseFloat(xPositionArr[index + 1].toFixed(6))) {
							//console.log("in if");
							if (sprite.exitsNextDay) {
								floorDifference = sprite.x - xPositionArr[index];

								sprite.width = sprite.width + floorDifference;
								//console.log("floorDifference, sprite.right", floorDifference, sprite.right);
							}
							sprite.x = xPositionArr[index];
							innerUpdatedFlag = true;
						} else if (parseFloat(spriteX.toFixed(6)) > parseFloat(xPositionArr[index].toFixed(6)) && !xPositionArr[
								index +
								1]) {
							//console.log("in else if");
							if (sprite.exitsNextDay) {
								floorDifference = sprite.x - xPositionArr[index];
								sprite.width = sprite.width + floorDifference;
								//console.log("floorDifference, sprite.right", floorDifference, sprite.right);
							}
							sprite.x = xPositionArr[index];
							innerUpdatedFlag = true;
						} else if (parseFloat(spriteX.toFixed(6)) == parseFloat(xPositionArr[index].toFixed(6))) {
							//console.log("in else if");
							if (sprite.exitsNextDay) {
								floorDifference = sprite.x - xPositionArr[index];
								sprite.width = sprite.width + floorDifference;
								//console.log("floorDifference, sprite.right", floorDifference, sprite.right);
							}
							sprite.x = xPositionArr[index];
							innerUpdatedFlag = true;
						} else {
							//console.log("in elsessssddidh");
						}
					});
					if (!innerUpdatedFlag) {
						sprite.x = xPositionArr[xPositionArr.length - 1];
					}
				} else {}
			});
		}


		function repositionSpriteBasedOnYGranularity(sprite) {
			console.log("in repositionSpriteBasedOnXGranularity", sprite.y);
			console.log("yAxisScalePositions", yAxisScalePositions);
			let spriteY = sprite.y
			let innerUpdatedFlag = false;
			let floorDifference;
			yAxisScalePositions.forEach(function (yPositionArr, parentIndex) {
				if ((spriteY < yAxisScalePositions[parentIndex][0] && yAxisScalePositions[parentIndex + 1] && spriteY >
						yAxisScalePositions[parentIndex + 1][0]) || spriteY ==
					yAxisScalePositions[parentIndex][0]) {
					//console.log("parent Index", parentIndex);
					yPositionArr.forEach(function (yPosition, index) {
						//console.log("child Index", index)
						if (parseFloat(spriteY.toFixed(6)) < parseFloat(yPositionArr[index].toFixed(6)) && yPositionArr[index + 1] &&
							parseFloat(spriteY.toFixed(6)) > parseFloat(yPositionArr[index + 1].toFixed(6))) {
							//console.log("in if", index);
							sprite.y = yPositionArr[index];
							innerUpdatedFlag = true;
						} else if (parseFloat(spriteY.toFixed(6)) < parseFloat(yPositionArr[index].toFixed(6)) && !yPositionArr[
								index +
								1]) {
							//console.log("in else if 1", index);
							sprite.y = yPositionArr[index];
							innerUpdatedFlag = true;
						} else if (parseFloat(spriteY.toFixed(6)) == parseFloat(yPositionArr[index].toFixed(6))) {
							//console.log("in else if 2", index);
							sprite.y = yPositionArr[index];
							innerUpdatedFlag = true;
						} else {
							//console.log("in else");
						}
					});
					if (!innerUpdatedFlag) {
						sprite.y = yPositionArr[yPositionArr.length - 1][0];
					}
				} else if (spriteY < yAxisScalePositions[parentIndex][0] && !yAxisScalePositions[parentIndex + 1]) {
					sprite.y = yPositionArr[0];
				} else if (spriteY > yAxisScalePositions[0][0]) {
					sprite.y = yAxisScalePositions[0][0];
				} else {}
			});
			//console.log("sprite.y", sprite.y);
		}


		function findInXAxisScalePositions(val) {
			let spriteX = Math.ceil(val)
			let spriteXFloored = Math.floor(val)
			for (let i = 0, length = xAxisScalePositions.length; i < length; i++) {
				if (spriteX > xAxisScalePositions[i][0] && xAxisScalePositions[i + 1] && spriteX < xAxisScalePositions[i + 1][0] ||
					spriteX ==
					xAxisScalePositions[i][0]) {
					for (let j = 0, len = xAxisScalePositions[i].length; j < len; j++) {
						if (spriteX == Math.ceil(xAxisScalePositions[i][j]) || spriteXFloored == Math.ceil(xAxisScalePositions[i][j])) {
							return {
								hourIndex: i,
								minuteIndex: j
							};
						}
					};
				} else if (!(xAxisScalePositions[i + 1])) {
					if (spriteX == Math.ceil(xAxisScalePositions[i][0]) || spriteXFloored == Math.ceil(xAxisScalePositions[i][0])) {
						return {
							hourIndex: i,
							minuteIndex: 0
						};
					}
				} else {}
			};
			return null;
		}

		function findInYAxisScalePositions(val) {
			let spriteY = Math.ceil(val)
			let spriteYFloored = Math.floor(val)
			for (let i = 0, length = yAxisScalePositions.length; i < length; i++) {
				if (spriteY < yAxisScalePositions[i][0] && yAxisScalePositions[i + 1] && spriteY > yAxisScalePositions[i + 1][0] ||
					spriteY == yAxisScalePositions[i][0]) {
					for (let j = 0, len = yAxisScalePositions[i].length; j < len; j++) {
						if (spriteY == Math.ceil(yAxisScalePositions[i][j]) || spriteYFloored == Math.ceil(yAxisScalePositions[i][j])) {
							return {
								parentIndex: i,
								childIndex: j
							};
						}
					};
				} else if (!(yAxisScalePositions[i + 1])) {
					if (spriteY == Math.ceil(yAxisScalePositions[i][0]) || spriteYFloored == Math.ceil(yAxisScalePositions[i][0])) {
						return {
							parentIndex: i,
							childIndex: 0
						};
					}
				} else {}
			};
			return null;
		}

		function updateShiftBarPosition(handler, handlerType) {
			//console.log("handlerType", handlerType);
			let counter = handler.counterVal;
			let handlerDistance = shiftBarRightHandlers[counter].x - shiftBarLeftHandlers[counter].x;
			if (myShiftbars[counter].exitsNextDay || myShiftbars[counter].exitsPrevDay) {
				myShiftbars[counter].x = shiftBarLeftHandlers[counter].x;
				myShiftbars[counter].width = handlerDistance;
			} else {
				if (handlerDistance < minimumShiftLength) {
					handlerDistance = minimumShiftLength;
					if (handlerType == "right") {
						shiftBarRightHandlers[counter].x = shiftBarOnClickIntitialXPosition.x + minimumShiftLength;
					} else {
						shiftBarLeftHandlers[counter].x = shiftBarOnClickIntitialXPosition.right - minimumShiftLength;
					}
				}
				myShiftbars[counter].x = shiftBarLeftHandlers[counter].x;
				myShiftbars[counter].width = handlerDistance;
			}
		}


		function emitPosition(sprite, event) {
			let counter = sprite.counterVal;
			//console.log("in emitPosition, (myShiftbars[counter].x", myShiftbars[counter].x, myShiftbars[counter].right);
			let barXIndex = findInXAxisScalePositions(myShiftbars[counter].x);
			let barRightIndex = findInXAxisScalePositions(myShiftbars[counter].right);

			if (barXIndex && barRightIndex) {
				console.log("Both Indexes Present", barXIndex, barRightIndex);
				barXIndex.minuteIndex = replaceMinuteIndexInMinutes(barXIndex.minuteIndex);
				barRightIndex.minuteIndex = replaceMinuteIndexInMinutes(barRightIndex.minuteIndex);
				let shiftTimeInfo = getCalculatedTimeFromIndexes(barXIndex, barRightIndex, counter, event);
				shiftTimeInfo.shiftId = myShiftbars[counter].shiftId;
				console.log("shiftTimeInfo", shiftTimeInfo);
			} else {
				alert("Both Indexes Not Present")
			}
		}

		function emitStaffLevels(sprite, counter, bar, levelType) {
			let barYIndex = findInYAxisScalePositions(bar[counter].y);
			if (barYIndex) {
				let staffLevel = calculateStaffLevel(barYIndex);
				let timeInterval = getBarTimeIntervalOnXAxis(counter);
				let staffLevelsInfo = {
					levelType: levelType,
					value: staffLevel,
					timeInterval: timeInterval
				}
				console.log("staffLevelsInfo", staffLevelsInfo);
			} else {
				alert("barYIndex Not Present")
			}

		}

		function getBarTimeIntervalOnXAxis(counter) {
			let reducedCounter = --counter; // since bar counter begins from 1 and for time calculation begins from 0
			return {
				startTime: {
					hours: Math.floor(reducedCounter / staffLevelsHourGranularity),
					minutes: (reducedCounter % staffLevelsHourGranularity) * (60 / staffLevelsHourGranularity),
				},
				endTime: {
					hours: Math.floor((reducedCounter + 1) / staffLevelsHourGranularity),
					minutes: ((reducedCounter + 1) % staffLevelsHourGranularity) * (60 / staffLevelsHourGranularity),
				}
			}
		}

		function calculateStaffLevel(barYIndex) {
			return barYIndex.parentIndex * staffLevelsScale + barYIndex.childIndex;
		}

		function replaceMinuteIndexInMinutes(index) {

			switch (hourGranularity) {

				case 1:
					{
						switch (index) {
							case 0:
								return 0;
							default:
								return null;
						}
					}
				case 2:
					{
						switch (index) {
							case 0:
								return 0;
							case 1:
								return 30;
							default:
								return null;
						}
					}
				case 4:
					{
						switch (index) {
							case 0:
								return 0;
							case 1:
								return 15;
							case 2:
								return 30;
							case 3:
								return 45;
							default:
								return null;
						}
					}
				case 12:
					{
						switch (index) {
							case 0:
								return 0;
							case 1:
								return 5;
							case 2:
								return 10;
							case 3:
								return 15;
							case 4:
								return 20;
							case 5:
								return 25;
							case 6:
								return 30;
							case 7:
								return 35;
							case 8:
								return 40;
							case 9:
								return 45;
							case 10:
								return 50;
							case 11:
								return 55;
							default:
								return null;
						}
					}
				default:
					{
						return 0;
					}
			}

		}

		function getCalculatedTimeFromIndexes(barXIndex, barRightIndex, counter, event) {
			let shiftTimeInfo = {};
			let startTime;
			let endTime;
			//console.log("myShiftbars[counter].startDateObj", myShiftbars[counter].startDateObj,myShiftbars[counter].endDateObj)
			if (myShiftbars[counter].exitsNextDay) {

				startTime = _.cloneDeep(myShiftbars[counter].startDateObj);
				endTime = _.cloneDeep(myShiftbars[counter].startDateObj);

				// add nextday offset Time
				endTime.setHours(myShiftbars[counter].endDateObj.getHours(), myShiftbars[counter].endDateObj.getMinutes())

			} else if (myShiftbars[counter].exitsPrevDay) {
				startTime = _.cloneDeep(myShiftbars[counter].endDateObj);
				endTime = _.cloneDeep(myShiftbars[counter].endDateObj);

				// sub prev day offset Time
				startTime.setHours(myShiftbars[counter].endDateObj.getHours(), myShiftbars[counter].endDateObj.getMinutes())

			} else {
				startTime = _.cloneDeep(myShiftbars[counter].startDateObj);
				endTime = _.cloneDeep(myShiftbars[counter].endDateObj);
			}
			startTime.setHours(barXIndex.hourIndex, barXIndex.minuteIndex);
			endTime.setHours(barRightIndex.hourIndex, barRightIndex.minuteIndex);

			updateOffsetHours(startTime, endTime, counter, event);

			shiftTimeInfo.startDate = startTime;
			shiftTimeInfo.endDate = endTime;
			return shiftTimeInfo;
		}

		function updateOffsetHours(startTime, endTime, counter, event) {

			if (myShiftbars[counter].exitsNextDay) { // add nextday offset Time

				let minutesDrag = dateFns.differenceInMinutes(myShiftbars[counter].startDateObj, startTime);
				if (event == "drag") {
					myShiftbars[counter].variableEndDateObj = dateFns.subMinutes(myShiftbars[counter].endDateObj, minutesDrag);
				} else if (event == "stretch") {
					myShiftbars[counter].startDateObj = _.cloneDeep(startTime);
					myShiftbars[counter].inverseNextDayTimeOffset = getInverseTimeIndexes(myShiftbars[counter].startDateObj,
						myShiftbars[counter].endDateObj,
						"nextDay")
					myShiftbars[counter].inverseNextDayXCoordinate = getXScaleCoordinatesFromIndex(myShiftbars[counter].inverseNextDayTimeOffset);
				}
				let variableEndDateTimeObj = getVariableDateObjTime(myShiftbars[counter].variableEndDateObj, "nextDay");
				//console.log(" minutesDrag", minutesDrag)
				//console.log("myShiftbars[counter].startDateObj", myShiftbars[counter].startDateObj)
				endTime.setHours(variableEndDateTimeObj.hour, variableEndDateTimeObj.minutes)
				let nextText = variableEndDateTimeObj.hour + "." + variableEndDateTimeObj.minutes + " hours - Extended";
				myShiftbars[counter].nextOffsetText.text = nextText;

			} else if (myShiftbars[counter].exitsPrevDay) { // sub prev day offset Time		

				startTime.setHours(myShiftbars[counter].startDateObj.getHours(), myShiftbars[counter].startDateObj.getMinutes());
				startTime.setDate(myShiftbars[counter].startDateObj.getDate())
			}
		}

		function getVariableDateObjTime(variableDateObj, scenario) {
			let hour;
			let minutes;
			if (scenario == "nextDay") {

				hour = variableDateObj.getHours();
				minutes = (variableDateObj.getMinutes() < 10 ? '0' : '') + variableDateObj.getMinutes();

			} else if (scenario == "prevDay") {

				//console.log("variableStartDateObj in getTime", variableDateObj)
				let clonedVariableDateObj = _.cloneDeep(variableDateObj);
				clonedVariableDateObj.setHours(24, 0, 0);
				let minutesDiff = dateFns.differenceInMinutes(clonedVariableDateObj, variableDateObj);
				hour = Math.floor((minutesDiff) / 60);
				minutes = (((minutesDiff) % 60) < 10 ? '0' : '') + ((minutesDiff) % 60);

			}
			return ({
				hour,
				minutes
			});
		}

		function createStaffLevelsBar(hourlyLevel, counter, spriteLevelsLength, spriteImg, spriteBar, spriteCenterHandler,
			handlerType, spriteRightHandler, spriteLeftHandler, spriteLeftLine, spriteMiddleLine, spriteLeftLineGraphic,
			spriteMiddleLineGraphic, spriteStaffLevelGroup, spriteHandlerDragStart, spriteHandlerDragUpdate,
			spriteHandlerDragStop, spriteColor) {


			// creating a bar sprite and positioning it according to available staff levels
			spriteBar[counter] = game.add.sprite(xAxisRef + ((counter - 1) * levelBarWidth), yAxisRef - hourlyLevel *
				yAxisScaleGranularWidth, spriteImg);
			spriteBar[counter].height = hourlyLevel * yAxisScaleGranularWidth;
			spriteBar[counter].width = levelBarWidth;
			spriteBar[counter].inputEnabled = true;
			spriteBar[counter].barName = "Bar-" + counter;
			spriteBar[counter].barId = counter;
			spriteBar[counter].alpha = 0.8;


			// creating and aligning the handler to the available bar sprite
			spriteCenterHandler[counter] = game.add.sprite(spriteBar[counter].centerX,
				spriteBar[counter].y, 'node');
			spriteCenterHandler[counter].counterVal = counter;
			spriteCenterHandler[counter].handlerType = handlerType;
			spriteCenterHandler[counter].anchor.set(0.5);
			spriteCenterHandler[counter].scale.setTo(0.1);
			spriteCenterHandler[counter].inputEnabled = true;
			spriteCenterHandler[counter].input.allowHorizontalDrag = false;
			spriteCenterHandler[counter].input.enableDrag(false, true);
			spriteCenterHandler[counter].input.useHandCursor = true;
			spriteCenterHandler[counter].input.boundsRect = positiveBounds;
			spriteCenterHandler[counter].visible = false;

			if (counter == 1) {
				spriteRightHandler[counter - 1] = game.add.sprite(xAxisRef, yAxisRef, 'node');
				spriteRightHandler[counter - 1].counterVal = counter - 1;
				spriteRightHandler[counter - 1].handlerType = handlerType;
				spriteRightHandler[counter - 1].anchor.set(0.5);
				spriteRightHandler[counter - 1].scale.setTo(0.04);
				spriteRightHandler[counter - 1].visible = false;
			}

			// creating and aligning the handler to the sprite bar sprite
			spriteLeftHandler[counter] = game.add.sprite(spriteBar[counter].x, spriteBar[counter].y, 'node');
			spriteLeftHandler[counter].counterVal = counter;
			spriteLeftHandler[counter].handlerType = handlerType;
			spriteLeftHandler[counter].visible = false;
			spriteLeftHandler[counter].anchor.set(0.5);
			spriteLeftHandler[counter].scale.setTo(0.04);

			// creating and aligning the handler to the sprite bar sprite
			spriteRightHandler[counter] = game.add.sprite(spriteBar[counter].right, spriteBar[counter].y, 'node');
			spriteRightHandler[counter].counterVal = counter;
			spriteRightHandler[counter].handlerType = handlerType;
			spriteRightHandler[counter].visible = false;
			spriteRightHandler[counter].anchor.set(0.5);
			spriteRightHandler[counter].scale.setTo(0.04);


			spriteLeftLine[counter] = new Phaser.Line(spriteLeftHandler[counter].x, spriteLeftHandler[counter].y,
				spriteRightHandler[
					counter - 1].x, spriteRightHandler[counter - 1].y);
			spriteMiddleLine[counter] = new Phaser.Line(spriteLeftHandler[counter].x, spriteLeftHandler[counter].y,
				spriteRightHandler[counter].x, spriteRightHandler[counter].y);

			spriteLeftLineGraphic[counter] = game.add.graphics(0, 0);
			spriteLeftLineGraphic[counter].lineStyle(2, spriteColor, 1);
			spriteLeftLineGraphic[counter].moveTo(spriteLeftHandler[counter].x, spriteLeftHandler[counter].y); //moving position of graphic if you draw mulitple lines
			spriteLeftLineGraphic[counter].lineTo(spriteRightHandler[counter - 1].x, spriteRightHandler[counter - 1].y);

			spriteMiddleLineGraphic[counter] = game.add.graphics(0, 0);
			spriteMiddleLineGraphic[counter].lineStyle(2, spriteColor, 1);
			spriteMiddleLineGraphic[counter].moveTo(spriteLeftHandler[counter].x, spriteLeftHandler[counter].y); //moving position of graphic if you draw mulitple lines
			spriteMiddleLineGraphic[counter].lineTo(spriteRightHandler[counter].x, spriteRightHandler[counter].y);

			if (counter == spriteLevelsLength) {
				spriteLeftHandler[counter + 1] = game.add.sprite(xAxisRef + ((counter) * levelBarWidth), yAxisRef, 'node');
				spriteLeftHandler[counter + 1].counterVal = counter + 1;
				spriteLeftHandler[counter + 1].handlerType = handlerType;
				spriteLeftHandler[counter + 1].anchor.set(0.5);
				spriteLeftHandler[counter + 1].scale.setTo(0.04);
				spriteLeftHandler[counter + 1].visible = false;
				spriteLeftLine[counter + 1] = new Phaser.Line(spriteLeftHandler[counter + 1].x, spriteLeftHandler[counter + 1].y,
					spriteRightHandler[counter].x, spriteRightHandler[counter].y);
				spriteLeftLineGraphic[counter + 1] = game.add.graphics(0, 0);
				spriteLeftLineGraphic[counter + 1].lineStyle(2, spriteColor, 1);
				spriteLeftLineGraphic[counter + 1].moveTo(spriteLeftHandler[counter + 1].x, spriteLeftHandler[counter + 1].y); //moving position of graphic if you draw mulitple lines
				spriteLeftLineGraphic[counter + 1].lineTo(spriteRightHandler[counter].x, spriteRightHandler[counter].y);
				spriteStaffLevelGroup.add(spriteLeftLineGraphic[counter + 1]);
			}

			// attaching events to the handler
			spriteCenterHandler[counter].events.onDragStart.add(spriteHandlerDragStart);
			spriteCenterHandler[counter].events.onDragUpdate.add(spriteHandlerDragUpdate);
			spriteCenterHandler[counter].events.onDragStop.add(spriteHandlerDragStop);

			spriteStaffLevelGroup.add(spriteBar[counter]);
			spriteStaffLevelGroup.add(spriteCenterHandler[counter]);
			spriteStaffLevelGroup.add(spriteLeftHandler[counter]);
			spriteStaffLevelGroup.add(spriteRightHandler[counter]);
			spriteStaffLevelGroup.add(spriteLeftLineGraphic[counter]);
			spriteStaffLevelGroup.add(spriteMiddleLineGraphic[counter]);

		}


		function availHandlerDragStart(handler, pointer, x, y) {
			let counter = handler.counterVal;
			availHandlerStartYCoordinate = y;
			availBarHeight = availBar[counter].height;
		}

		function availHandlerDragUpdate(handler, pointer, x, y, snapOnDrag, fromStart) {
			let counter = handler.counterVal;
			let handlerType = handler.handlerType;
			availDragDist = availHandlerStartYCoordinate - handler.y;
			//console.log("availDragDist", availDragDist);
			if (!isNaN(availDragDist)) {
				availBar[counter].height = availBarHeight + availDragDist;
				availBar[counter].y = handler.y;

				availRightHandler[counter].y = availLeftHandler[counter].y = availBar[
					counter].y;

				availLeftLine[counter].fromSprite(availLeftHandler[counter], availRightHandler[
					counter - 1], false);
				availLeftLine[counter + 1].fromSprite(availLeftHandler[counter + 1], availRightHandler[
					counter], false);
				availMiddleLine[counter].fromSprite(availLeftHandler[counter], availRightHandler[
					counter], false);

				availLeftLineGraphic[counter].clear();
				availLeftLineGraphic[counter].lineStyle(2, availColor, 1);
				availLeftLineGraphic[counter].moveTo(availLeftHandler[counter].x, availLeftHandler[
					counter].y); //moving position of graphic if you draw mulitple lines
				availLeftLineGraphic[counter].lineTo(availRightHandler[counter - 1].x, availRightHandler[
					counter - 1].y);

				availLeftLineGraphic[counter + 1].clear();
				availLeftLineGraphic[counter + 1].lineStyle(2, availColor, 1);
				availLeftLineGraphic[counter + 1].moveTo(availLeftHandler[counter + 1].x,
					availLeftHandler[counter + 1].y); //moving position of graphic if you draw mulitple lines
				availLeftLineGraphic[counter + 1].lineTo(availRightHandler[counter].x, availRightHandler[
					counter].y);

				availMiddleLineGraphic[counter].clear();
				availMiddleLineGraphic[counter].lineStyle(2, availColor, 1);
				availMiddleLineGraphic[counter].moveTo(availLeftHandler[counter].x, availLeftHandler[
					counter].y); //moving position of graphic if you draw mulitple lines
				availMiddleLineGraphic[counter].lineTo(availRightHandler[counter].x, availRightHandler[
					counter].y);

				updateConflictArea(counter);
			}

		}

		function availHandlerDragStop(handler, pointer) {
			let counter = handler.counterVal;
			repositionSpriteBasedOnYGranularity(handler);
			availHandlerDragUpdate(handler); // calling function again to update line graphics, staff bar height after repositioning of handler 
			emitStaffLevels(handler, counter, availBar, "availBar");
		}

		function minReqHandlerDragStart(handler, pointer, x, y) {
			let counter = handler.counterVal;
			minReqHandlerStartYCoordinate = y;
			minRequiredBarHeight = minRequiredBar[counter].height;
		}

		function minReqHandlerDragUpdate(handler, pointer, x, y, snapOnDrag, fromStart) {
			let counter = handler.counterVal;
			let handlerType = handler.handlerType;
			minReqDragDist = minReqHandlerStartYCoordinate - handler.y;
			//console.log("minReqDragDist", minReqDragDist);
			if (!isNaN(minReqDragDist)) {
				minRequiredBar[counter].height = minRequiredBarHeight + minReqDragDist;
				minRequiredBar[counter].y = handler.y;

				minReqRightHandler[counter].y = minReqLeftHandler[counter].y = minRequiredBar[
					counter].y;

				minReqLeftLine[counter].fromSprite(minReqLeftHandler[counter], minReqRightHandler[
					counter - 1], false);
				minReqLeftLine[counter + 1].fromSprite(minReqLeftHandler[counter + 1],
					minReqRightHandler[counter], false);
				minReqMiddleLine[counter].fromSprite(minReqLeftHandler[counter], minReqRightHandler[
					counter], false);

				minReqLeftLineGraphic[counter].clear();
				minReqLeftLineGraphic[counter].lineStyle(2, minReqColor, 1);
				minReqLeftLineGraphic[counter].moveTo(minReqLeftHandler[counter].x, minReqLeftHandler[
					counter].y); //moving position of graphic if you draw mulitple lines
				minReqLeftLineGraphic[counter].lineTo(minReqRightHandler[counter - 1].x,
					minReqRightHandler[counter - 1].y);

				minReqLeftLineGraphic[counter + 1].clear();
				minReqLeftLineGraphic[counter + 1].lineStyle(2, minReqColor, 1);
				minReqLeftLineGraphic[counter + 1].moveTo(minReqLeftHandler[counter + 1].x,
					minReqLeftHandler[counter + 1].y); //moving position of graphic if you draw mulitple lines
				minReqLeftLineGraphic[counter + 1].lineTo(minReqRightHandler[counter].x,
					minReqRightHandler[counter].y);

				minReqMiddleLineGraphic[counter].clear();
				minReqMiddleLineGraphic[counter].lineStyle(2, minReqColor, 1);
				minReqMiddleLineGraphic[counter].moveTo(minReqLeftHandler[counter].x,
					minReqLeftHandler[
						counter].y); //moving position of graphic if you draw mulitple lines
				minReqMiddleLineGraphic[counter].lineTo(minReqRightHandler[counter].x,
					minReqRightHandler[counter].y);

				updateConflictArea(counter)
			}
		}

		function minReqHandlerDragStop(handler, pointer) {
			let counter = handler.counterVal;
			repositionSpriteBasedOnYGranularity(handler);
			minReqHandlerDragUpdate(handler); // calling function again to update line graphics, staff bar height after repositioning of handler 
			emitStaffLevels(handler, counter, minRequiredBar, "minReqBar");
		}

		function maxReqHandlerDragStart(handler, pointer, x, y) {
			let counter = handler.counterVal;
			maxReqHandlerStartYCoordinate = y;
			maxRequiredBarHeight = maxRequiredBar[counter].height;
		}

		function maxReqHandlerDragUpdate(handler, pointer, x, y, snapOnDrag, fromStart) {
			let counter = handler.counterVal;
			let handlerType = handler.handlerType;
			maxReqDragDist = maxReqHandlerStartYCoordinate - handler.y;
			//console.log("maxReqDragDist", maxReqDragDist);
			if (!isNaN(maxReqDragDist)) {
				maxRequiredBar[counter].height = maxRequiredBarHeight + maxReqDragDist;
				maxRequiredBar[counter].y = handler.y;

				maxReqRightHandler[counter].y = maxReqLeftHandler[counter].y = maxRequiredBar[
					counter].y;

				maxReqLeftLine[counter].fromSprite(maxReqLeftHandler[counter], maxReqRightHandler[
					counter - 1], false);
				maxReqLeftLine[counter + 1].fromSprite(maxReqLeftHandler[counter + 1],
					maxReqRightHandler[counter], false);
				maxReqMiddleLine[counter].fromSprite(maxReqLeftHandler[counter], maxReqRightHandler[
					counter], false);

				maxReqLeftLineGraphic[counter].clear();
				maxReqLeftLineGraphic[counter].lineStyle(2, maxReqColor, 1);
				maxReqLeftLineGraphic[counter].moveTo(maxReqLeftHandler[counter].x, maxReqLeftHandler[
					counter].y); //moving position of graphic if you draw mulitple lines
				maxReqLeftLineGraphic[counter].lineTo(maxReqRightHandler[counter - 1].x,
					maxReqRightHandler[counter - 1].y);

				maxReqLeftLineGraphic[counter + 1].clear();
				maxReqLeftLineGraphic[counter + 1].lineStyle(2, maxReqColor, 1);
				maxReqLeftLineGraphic[counter + 1].moveTo(maxReqLeftHandler[counter + 1].x,
					maxReqLeftHandler[counter + 1].y); //moving position of graphic if you draw mulitple lines
				maxReqLeftLineGraphic[counter + 1].lineTo(maxReqRightHandler[counter].x,
					maxReqRightHandler[counter].y);

				maxReqMiddleLineGraphic[counter].clear();
				maxReqMiddleLineGraphic[counter].lineStyle(2, maxReqColor, 1);
				maxReqMiddleLineGraphic[counter].moveTo(maxReqLeftHandler[counter].x,
					maxReqLeftHandler[
						counter].y); //moving position of graphic if you draw mulitple lines
				maxReqMiddleLineGraphic[counter].lineTo(maxReqRightHandler[counter].x,
					maxReqRightHandler[counter].y);

				updateConflictArea(counter)
			}
		}

		function maxReqHandlerDragStop(handler, pointer) {
			let counter = handler.counterVal;
			repositionSpriteBasedOnYGranularity(handler);
			maxReqHandlerDragUpdate(handler); // calling function again to update line graphics, staff bar height after repositioning of handler 
			emitStaffLevels(handler, counter, maxRequiredBar, "maxReqBar");
		}

		function update() {}

		function render() {
			//game.debug.geom(positiveBounds, 'rgba(200,0,0,0.5)');
		}

		function createScale() {

			xAxis = new Phaser.Line(0, yAxisRef + 1, gameWidth, yAxisRef + 1);
			yAxis = new Phaser.Line(xAxisRef, parseInt('00', 8), xAxisRef, gameHeight);
			var xAxisGraphics = game.add.graphics(0, 0);
			xAxisGraphics.lineStyle(2, 0xb1b1b1);
			xAxisGraphics.moveTo(xAxis.start.x, xAxis.start.y); // moving position of graphic if you draw mulitple lines
			xAxisGraphics.lineTo(xAxis.end.x, xAxis.end.y);
			xAxisGraphics.endFill();
			var yAxisGraphics = game.add.graphics(0, 0);
			yAxisGraphics.lineStyle(2, 0xb1b1b1);
			yAxisGraphics.moveTo(yAxis.start.x, yAxis.start.y); // moving position of graphic if you draw mulitple lines
			yAxisGraphics.lineTo(yAxis.end.x, yAxis.end.y);
			yAxisGraphics.endFill();

			createXAxisText();
			createYAxisText();
		}

		function createXAxisText() {
			var loopCounter = 1;
			while (loopCounter <= 25) {
				/********* X Axis Text **********/
				xAxisScalePositions[loopCounter - 1] = [];
				let innerLoopCounter = 0
				/********* Loop to granularize hours into minutes (15, 30, 60) **********/
				while (hourGranularity - 1 >= innerLoopCounter) {
					let xTextPos = (xAxisRef + (xAxisBarWidth * (loopCounter - 1))) + (xAxisBarWidth / hourGranularity) *
						innerLoopCounter

					if (innerLoopCounter === 0 && loopCounter !== 1) { // && used to avoid printing of 0
						xScaleText[loopCounter - 1] = game.add.text(xTextPos, yAxisRef +
							scaleTextDistFromX, loopCounter - 1, {
								fontSize: "22px"
							});
						xAxisScalePositions[loopCounter - 1].push(xTextPos);
						xScaleText[loopCounter - 1].anchor.setTo(0.5, 0.5);
						xScaleText[loopCounter - 1].addColor('#b1b1b1');
					} else {
						xAxisScalePositions[loopCounter - 1].push(xTextPos);
					}

					innerLoopCounter++;
				}
				loopCounter++;
			}
		}

		function createYAxisText() {

			let loopCounter = 0;
			let positiveTextValue = 0;
			while (loopCounter <= 7) {

				let innerLoopCounter = 0
				let granularArray = [];
				// to print +ve Y axis value
				while (innerLoopCounter < staffLevelsScale) {
					let positiveTextYPos = (yAxisRef - ((loopCounter) * yAxisScaleWidth)) - ((yAxisScaleGranularWidth) *
						innerLoopCounter);
					let negativeTextYPos = yAxisRef + ((loopCounter) * yAxisScaleWidth);

					if (innerLoopCounter === 0 && loopCounter !== 0) { // && used to avoid printing of 0
						positiveTextValue += staffLevelsScale;
						yScaleTextPositive[loopCounter] = game.add.text((xAxisRef - scaleTextDistFromY), positiveTextYPos,
							positiveTextValue, {
								fontSize: "16px"
							});
						yScaleTextPositive[loopCounter].anchor.setTo(0.5, 0.5);
						yScaleTextPositive[loopCounter].addColor('#b1b1b1');
						granularArray.push(positiveTextYPos);

						yScaleTextNegative[loopCounter] = game.add.text((xAxisRef - scaleTextDistFromY), negativeTextYPos, -
							positiveTextValue, {
								fontSize: "16px"
							});
						yScaleTextNegative[loopCounter].anchor.setTo(0.5, 0.5);
						yScaleTextNegative[loopCounter].addColor('#b1b1b1');
					} else {
						granularArray.push(positiveTextYPos);
					}
					innerLoopCounter++;
				}
				yAxisScalePositions.push(granularArray);
				loopCounter++;
			}
			console.log("yAxisScalePositions", yAxisScalePositions);
			positiveBounds.y = yAxisScalePositions[yAxisScalePositions.length - 1][0] - 10;
			positiveBounds.height -= yAxisScalePositions[yAxisScalePositions.length - 1][0] - 10;
		}

		function indicateConflictAreas() {

			let loopCounter = 1;
			let x1, x2, y1, y2;
			for (var eachHour in shiftData.availableLevels) {
				y1 = shiftData.minRequiredLevels[eachHour] * yAxisScaleGranularWidth; // y coordinate of reqLevels
				y2 = shiftData.availableLevels[eachHour] * yAxisScaleGranularWidth; // y coordinate of availableLevels

				if (y1 > y2) {
					x1 = xAxisRef + ((loopCounter - 1) * levelBarWidth); //x coordinate of the Hour Bar (same for both levels)
					x2 = xAxisRef + ((loopCounter) * levelBarWidth); //(x coordinate + width) of the Hour Bar (same for both levels)

					underStaffPolygon[loopCounter] = new Phaser.Polygon();
					underStaffPolygon[loopCounter].setTo([{
							x: x1,
							y: yAxisRef - y1
						},
						{
							x: x2,
							y: yAxisRef - y1
						},
						{
							x: x2,
							y: yAxisRef - y2
						},
						{
							x: x1,
							y: yAxisRef - y2
						},
					]);
					//console.log( underStaffPolygon[loopCounter]);
					underStaffGraphic[loopCounter] = game.add.graphics(0, 0);
					//underStaffGraphic[loopCounter].lineStyle(2, 0xcacacb);
					underStaffGraphic[loopCounter].beginFill(0X9c1003);
					underStaffGraphic[loopCounter].drawPolygon(underStaffPolygon[loopCounter].points);
					//underStaffGraphic[loopCounter].alpha = 0.5;
					underStaffGraphic[loopCounter].endFill();
					polygonGroup.add(underStaffGraphic[loopCounter]);
				}

				y1 = shiftData.maxRequiredLevels[eachHour] * yAxisScaleGranularWidth; // y coordinate of reqLevels
				y2 = shiftData.availableLevels[eachHour] * yAxisScaleGranularWidth; // y coordinate of availableLevels

				if (y1 < y2) {
					x1 = xAxisRef + ((loopCounter - 1) * levelBarWidth); //x coordinate of the Hour Bar (same for both levels)
					x2 = xAxisRef + ((loopCounter) * levelBarWidth); //(x coordinate + width) of the Hour Bar (same for both levels)

					overStaffPolygon[loopCounter] = new Phaser.Polygon();
					overStaffPolygon[loopCounter].setTo([{
							x: x1,
							y: yAxisRef - y1
						},
						{
							x: x2,
							y: yAxisRef - y1
						},
						{
							x: x2,
							y: yAxisRef - y2
						},
						{
							x: x1,
							y: yAxisRef - y2
						},
					]);
					overStaffGraphic[loopCounter] = game.add.graphics(0, 0);
					//overStaffGraphic[loopCounter].lineStyle(2, 0xcacacb);
					overStaffGraphic[loopCounter].beginFill(0xe3da7d);
					overStaffGraphic[loopCounter].drawPolygon(overStaffPolygon[loopCounter].points);
					//overStaffGraphic[loopCounter].alpha = 0.4;
					overStaffGraphic[loopCounter].endFill();
					polygonGroup.add(overStaffGraphic[loopCounter]);
				}

				loopCounter++;
			}
		}

		function updateConflictArea(counter) {

			//console.log("in updateConflictArea");
			let polygonExists = false;
			if (typeof underStaffGraphic[counter] !== "undefined") {
				underStaffGraphic[counter].clear();
			}

			if (typeof overStaffGraphic[counter] !== "undefined") {
				overStaffGraphic[counter].clear();
			}

			let availBarY = availBar[counter].y;
			let availBarX = availBar[counter].x;
			let minReqBarY = minRequiredBar[counter].y;
			let minReqBarX = minRequiredBar[counter].x;
			let maxReqBarY = maxRequiredBar[counter].y;
			let maxReqBarX = maxRequiredBar[counter].x;
			let conflict;

			if (availBarY > minReqBarY) {
				conflict = "underStaff";
			} else if (availBarY < maxReqBarY) {
				conflict = "overStaff";
			} else {
				conflict = null;
			}

			switch (conflict) {
				case "underStaff":
					underStaffPolygon[counter] = new Phaser.Polygon();
					underStaffPolygon[counter].setTo([{
							x: availBarX,
							y: availBarY
						},
						{
							x: availBarX + levelBarWidth,
							y: availBarY
						},
						{
							x: minReqBarX + levelBarWidth,
							y: minReqBarY
						},
						{
							x: minReqBarX,
							y: minReqBarY
						},
					]);
					underStaffGraphic[counter] = game.add.graphics(0, 0);
					underStaffGraphic[counter].beginFill(0X9c1003);
					underStaffGraphic[counter].drawPolygon(underStaffPolygon[counter].points);
					underStaffGraphic[counter].endFill();
					polygonGroup.add(underStaffGraphic[counter]);
					break;

				case "overStaff":
					overStaffPolygon[counter] = new Phaser.Polygon();
					overStaffPolygon[counter].setTo([{
							x: availBarX,
							y: availBarY
						},
						{
							x: availBarX + levelBarWidth,
							y: availBarY
						},
						{
							x: maxReqBarX + levelBarWidth,
							y: maxReqBarY
						},
						{
							x: maxReqBarX,
							y: maxReqBarY
						},
					]);
					console.log(overStaffPolygon[counter]);
					overStaffGraphic[counter] = game.add.graphics(0, 0);
					overStaffGraphic[counter].beginFill(0xe3da7d);
					overStaffGraphic[counter].drawPolygon(overStaffPolygon[counter].points);
					overStaffGraphic[counter].endFill();
					polygonGroup.add(overStaffGraphic[counter]);
					break;

				default:

			}
		}

		function createButtons() {

			button = game.add.button(300, 400, 'sky', actionOnClick);
			button.scale.setTo(0.05)
		}

		function actionOnClick() {

			console.log('click');

			button.inputEnabled = false;

			// this.game.canvas.style.cursor = "default";

		}

		$('.onTopSelect').on('change', function () {
			//minReqStaffLevelGroup.visible = false;
			let activeGroup = this.value;
			switch (activeGroup) {
				case "avail":
					game.world.bringToTop(availStaffLevelGroup);
					for (var i in availCenterHandler) {
						minReqCenterHandler[i].visible = false;
						maxReqCenterHandler[i].visible = false;
						availCenterHandler[i].visible = true;
						//sickCenterHandler[i].visible = false;
					}
					break;

				case "minReq":
					game.world.bringToTop(minReqStaffLevelGroup);
					for (var i in minReqCenterHandler) {
						minReqCenterHandler[i].visible = true;
						maxReqCenterHandler[i].visible = false;
						availCenterHandler[i].visible = false;
						//sickCenterHandler[i].visible = false;
					}
					break;

				case "maxReq":
					game.world.bringToTop(maxReqStaffLevelGroup);
					for (var i in maxReqCenterHandler) {
						minReqCenterHandler[i].visible = false;
						maxReqCenterHandler[i].visible = true;
						availCenterHandler[i].visible = false;
						//sickCenterHandler[i].visible = false;
					}
					break;

				case "sick":
					game.world.bringToTop(sickStaffLevelGroup);
					for (var i in sickCenterHandler) {
						minReqCenterHandler[i].visible = false;
						maxReqCenterHandler[i].visible = false;
						availCenterHandler[i].visible = false;
						//sickCenterHandler[i].visible = true;

					}
					break;

				default:
					game.world.bringToTop(availStaffLevelGroup);
					game.world.bringToTop(minReqStaffLevelGroup);
					game.world.bringToTop(maxReqStaffLevelGroup);
					game.world.bringToTop(polygonGroup);
					game.world.bringToTop(shiftBarsGroup);
					for (var i in maxReqCenterHandler) {
						minReqCenterHandler[i].visible = false;
						maxReqCenterHandler[i].visible = false;
						availCenterHandler[i].visible = false;
						//sickCenterHandler[i].visible = false;
					}
			}
		});
	</script>

</body>

</html>