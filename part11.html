<!doctype html> 
<html lang="en"> 
<head> 
	<meta charset="UTF-8" />
    <title>Phaser - Staffing Level Graph</title>
    <script src="//cdn.jsdelivr.net/phaser/2.6.2/phaser.min.js"></script>
    <style type="text/css">
        body {
            margin: 0;
            background: #e0e0e0;
            text-align: center;
        }
        canvas, iframe{
            position: absolute;
            top:0;
            bottom: 0;
            left: 0;
            right: 0;
            margin:auto;
        }
    </style>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
</head>
<body>
<p>Select to Edit a Layer</p>
<select class="onTopSelect">
    <option value = "" selected>None</option>
    <option value = "avail" >Available</option>
    <option value = "minReq" >MinRequired</option>
    <option value = "maxReq" >MaxRequired</option>
    <option value = "sick" >Sick</option>
</select>

<script type="text/javascript">

var game = new Phaser.Game(800, 400, Phaser.AUTO, '', { preload: preload, create: create, update: update, render: render });

//shift data object

var shiftData = {
    "shiftScale": 1,
    "availableLevels": {
        "0 - 1" : 8,
        "1 - 2" : 3,
        "2 - 3" : 7,
        "3 - 4" : 10,
        "4 - 5" : 9,
        "5 - 6" : 9,
        "6 - 7" : 9,
        "7 - 8" : 7,
        "8 - 9" : 7,
        "9 - 10" : 7,
        "10 - 11" : 6,
        "11 - 12" : 4,
        "12 - 13" : 4,
        "13 - 14" : 8,
        "14 - 15" : 11,
        "15 - 16" : 15,
        "16 - 17" : 15,
        "17 - 18" : 15,
        "18 - 19" : 10,
        "19 - 20" : 10,
        "20 - 21" : 13,
        "21 - 22" : 2,
        "22 - 23" : 2,
        "23 - 24" : 13,
    },
    "minRequiredLevels": {
        "0 - 1" : 6,
        "1 - 2" : 10,
        "2 - 3" : 8,
        "3 - 4" : 9,
        "4 - 5" : 8,
        "5 - 6" : 8,
        "6 - 7" : 8,
        "7 - 8" : 5,
        "8 - 9" : 6,
        "9 - 10" : 6,
        "10 - 11" : 4,
        "11 - 12" : 6,
        "12 - 13" : 6,
        "13 - 14" : 10,
        "14 - 15" : 10,
        "15 - 16" : 10,
        "16 - 17" : 10,
        "17 - 18" : 7,
        "18 - 19" : 8,
        "19 - 20" : 8,
        "20 - 21" : 12,
        "21 - 22" : 8,
        "22 - 23" : 9,
        "23 - 24" : 11,
    },
    "maxRequiredLevels": {
        "0 - 1" : 8,
        "1 - 2" : 11,
        "2 - 3" : 12,
        "3 - 4" : 13,
        "4 - 5" : 13,
        "5 - 6" : 13,
        "6 - 7" : 10,
        "7 - 8" : 10,
        "8 - 9" : 10,
        "9 - 10" : 8,
        "10 - 11" : 12,
        "11 - 12" : 9,
        "12 - 13" : 11,
        "13 - 14" : 11,
        "14 - 15" : 11,
        "15 - 16" : 12,
        "16 - 17" : 12,
        "17 - 18" : 12,
        "18 - 19" : 11,
        "19 - 20" : 11,
        "20 - 21" : 14,
        "21 - 22" : 10,
        "22 - 23" : 11,
        "23 - 24" : 11,
    },      
    "sickLevels": {
        "0 - 1" : 0,
        "1 - 2" : 0,
        "2 - 3" : 0,
        "3 - 4" : 0,
        "4 - 5" : 5,
        "5 - 6" : 5,
        "6 - 7" : 5,
        "7 - 8" : 5,
        "8 - 9" : 5,
        "9 - 10" : 0,
        "10 - 11" : 0,
        "11 - 12" : 6,
        "12 - 13" : 4,
        "13 - 14" : 0,
        "14 - 15" : 3,
        "15 - 16" : 4,
        "16 - 17" : 0,
        "17 - 18" : 0,
        "18 - 19" : 0,
        "19 - 20" : 0,
        "20 - 21" : 0,
        "21 - 22" : 0,
        "22 - 23" : 0,
        "23 - 24" : 0
    }                
}

//common vars
var xScaleText = [];
var yScaleTextPositive = [];
var yScaleTextNegative = [];
var yAxisRef = 200;     //multiple of 10
var xAxisRef = 30;
var hourScale = 30;
var underStaffPolygon = [];
var overStaffPolygon = [];
var underStaffGraphic = [];
var overStaffGraphic = [];
var polygonGroup;
var positiveBounds;
var negativeBounds;

// minRequiredLevels vars
var minReqColor = 0x557d1d;
var minReqHandlerStartYCoordinate;
var minReqCenterHandlerId;
var minReqDragDist;
var minRequiredBarHeight;
var minRequiredBar = [];
var minReqCenterHandler = [];
var minReqLeftHandler = [];
var minReqRightHandler = [];
var minReqLeftLine = [];
var minReqMiddleLine = [];
var minReqLeftLineGraphic = [];
var minReqMiddleLineGraphic = [];
var minReqStaffLevelGroup;
var minRequiredLevelsLength = Object.keys(shiftData.minRequiredLevels).length;

// maxRequiredLevels vars
var maxReqColor = 0xeea2b7;
var maxReqHandlerStartYCoordinate;
var maxReqCenterHandlerId;
var maxReqDragDist;
var maxRequiredBarHeight;
var maxRequiredBar = [];
var maxReqCenterHandler = [];
var maxReqLeftHandler = [];
var maxReqRightHandler = [];
var maxReqLeftLine = [];
var maxReqMiddleLine = [];
var maxReqLeftLineGraphic = [];
var maxReqMiddleLineGraphic = [];
var maxReqStaffLevelGroup;
var maxRequiredLevelsLength = Object.keys(shiftData.maxRequiredLevels).length;

// availableLevels vars
var availColor = 0xcacacb;
var availHandlerStartYCoordinate;
var availCenterHandlerId;
var availDragDist;
var availBarHeight;
var availBar = [];
var availCenterHandler = [];
var availLeftHandler = [];
var availRightHandler = [];
var availLeftLine = [];
var availMiddleLine = [];
var availLeftLineGraphic = [];
var availMiddleLineGraphic = [];
var availStaffLevelGroup;
var availableLevelsLength = Object.keys(shiftData.availableLevels).length;

// sickLevels vars
var sickColor = 0xade1f7;
var sickHandlerStartYCoordinate;
var sickCenterHandlerId;
var sickDragDist;
var sickBarHeight;
var sickBar = [];
var sickCenterHandler = [];
var sickLeftHandler = [];
var sickRightHandler = [];
var sickLeftLine = [];
var sickMiddleLine = [];
var sickLeftLineGraphic = [];
var sickMiddleLineGraphic = [];
var sickStaffLevelGroup;
var sickLevelsLength = Object.keys(shiftData.sickLevels).length;


function preload() {
    game.load.image('greyImage', 'assets/greyImage.jpg');
    game.load.image('transparent', 'assets/transparent.png');
    game.load.image('node', 'assets/circle_blue.png');
    game.load.image('sky', 'assets/sky.png');
}

function create() {
    game.stage.backgroundColor = '#ffffff';
    positiveBounds = new Phaser.Rectangle(xAxisRef, 00, 720, yAxisRef); 
    negativeBounds = new Phaser.Rectangle(xAxisRef, yAxisRef-4, 720, yAxisRef-10); 

    loopCounter = 1;
    sickStaffLevelGroup = game.add.group();
    // loop to iterate over sick staff levels for each hour 
    for (var eachHour in shiftData.sickLevels) {
        if (shiftData.sickLevels.hasOwnProperty(eachHour)) {
            createSickHourBar(shiftData.sickLevels[eachHour], loopCounter, sickLevelsLength);
            loopCounter++;
        }
    }        

    loopCounter = 1;
    availStaffLevelGroup = game.add.group();
    // loop to iterate over available staff levels for each hour 
    for (var eachHour in shiftData.availableLevels) {
        if (shiftData.availableLevels.hasOwnProperty(eachHour)) {
            createAvailableHourBar(shiftData.availableLevels[eachHour], loopCounter, availableLevelsLength);
            loopCounter++;
        }
    }

    loopCounter = 1;
    minReqStaffLevelGroup = game.add.group();
    // loop to iterate over minRequired staff levels for each hour 
    for (var eachHour in shiftData.minRequiredLevels) {
        if (shiftData.minRequiredLevels.hasOwnProperty(eachHour)) {
            createminRequiredHourBar(shiftData.minRequiredLevels[eachHour], loopCounter, minRequiredLevelsLength);
            loopCounter++;
        }
    }

    loopCounter = 1;
    maxReqStaffLevelGroup = game.add.group();
    // loop to iterate over maxRequired staff levels for each hour 
    for (var eachHour in shiftData.maxRequiredLevels) {
        if (shiftData.maxRequiredLevels.hasOwnProperty(eachHour)) {
            createmaxRequiredHourBar(shiftData.maxRequiredLevels[eachHour], loopCounter, maxRequiredLevelsLength);
            loopCounter++;
        }
    }
   
    polygonGroup = game.add.group();
    createScale();
    indicateConflictAreas();    
}





function createAvailableHourBar( hourlyLevel, counter, availableLevelsLength ){


    // creating a bar sprite and positioning it according to available staff levels
    availBar[counter] = game.add.sprite(xAxisRef + ((counter-1)*30), yAxisRef - hourlyLevel*10, 'greyImage');
    availBar[counter].height = hourlyLevel*10;
    availBar[counter].width = 30;
    availBar[counter].inputEnabled = true;
    availBar[counter].barName = "Bar-" + counter;
    availBar[counter].barId = counter;
    availBar[counter].alpha = 0.8;

    
    // creating and aligning the handler to the available bar sprite
    availCenterHandler[counter] = game.add.sprite(xAxisRef + ((counter-1)*30) + 15, yAxisRef - hourlyLevel*10, 'node');
    availCenterHandler[counter].availCenterHandlerId = counter;
    availCenterHandler[counter].anchor.set(0.5);
    availCenterHandler[counter].scale.setTo(0.05);
    availCenterHandler[counter].inputEnabled = true;
    availCenterHandler[counter].input.allowHorizontalDrag = false;
    availCenterHandler[counter].input.enableDrag(false, true);
    availCenterHandler[counter].input.useHandCursor = true;
    availCenterHandler[counter].input.boundsRect = positiveBounds;
    availCenterHandler[counter].visible = false;

    if(counter == 1){
        availRightHandler[counter-1] = game.add.sprite(xAxisRef, yAxisRef, 'node');
        availRightHandler[counter-1].availLeftHandlerId = counter-1;
        availRightHandler[counter-1].anchor.set(0.5);
        availRightHandler[counter-1].scale.setTo(0.04); 
        availRightHandler[counter-1].visible = false; 
    }

    // creating and aligning the handler to the available bar sprite
    availLeftHandler[counter] = game.add.sprite(xAxisRef + ((counter-1)*30), yAxisRef - hourlyLevel*10, 'node');
    availLeftHandler[counter].availLeftHandlerId = counter;
    availLeftHandler[counter].visible = false;
    availLeftHandler[counter].anchor.set(0.5);
    availLeftHandler[counter].scale.setTo(0.04);   

    // creating and aligning the handler to the available bar sprite
    availRightHandler[counter] = game.add.sprite(xAxisRef + ((counter)*30), yAxisRef - hourlyLevel*10, 'node');
    availRightHandler[counter].availRightHandlerId = counter;
    availRightHandler[counter].visible = false;
    availRightHandler[counter].anchor.set(0.5);
    availRightHandler[counter].scale.setTo(0.04);
  
    
    availLeftLine[counter] = new Phaser.Line(availLeftHandler[counter].x, availLeftHandler[counter].y, availRightHandler[counter-1].x, availRightHandler[counter-1].y);         
    availMiddleLine[counter] = new Phaser.Line(availLeftHandler[counter].x, availLeftHandler[counter].y, availRightHandler[counter].x, availRightHandler[counter].y);         
    
    availLeftLineGraphic[counter]=game.add.graphics(0,0);
    availLeftLineGraphic[counter].lineStyle(2, availColor, 1);
    availLeftLineGraphic[counter].moveTo(availLeftHandler[counter].x, availLeftHandler[counter].y);//moving position of graphic if you draw mulitple lines
    availLeftLineGraphic[counter].lineTo(availRightHandler[counter-1].x, availRightHandler[counter-1].y);

    availMiddleLineGraphic[counter]=game.add.graphics(0,0);
    availMiddleLineGraphic[counter].lineStyle(2, availColor, 1);
    availMiddleLineGraphic[counter].moveTo(availLeftHandler[counter].x, availLeftHandler[counter].y);//moving position of graphic if you draw mulitple lines
    availMiddleLineGraphic[counter].lineTo(availRightHandler[counter].x, availRightHandler[counter].y);

    if(counter ==  availableLevelsLength){
        availLeftHandler[counter+1] = game.add.sprite(xAxisRef + ((counter)*30), yAxisRef, 'node');
        availLeftHandler[counter+1].availLeftHandlerId = counter+1;
        availLeftHandler[counter+1].anchor.set(0.5);
        availLeftHandler[counter+1].scale.setTo(0.04); 
        availLeftHandler[counter+1].visible = false; 
        availLeftLine[counter+1] = new Phaser.Line(availLeftHandler[counter+1].x, availLeftHandler[counter+1].y, availRightHandler[counter].x, availRightHandler[counter].y);                   
        availLeftLineGraphic[counter+1]=game.add.graphics(0,0);
        availLeftLineGraphic[counter+1].lineStyle(2, availColor, 1);
        availLeftLineGraphic[counter+1].moveTo(availLeftHandler[counter+1].x, availLeftHandler[counter+1].y);//moving position of graphic if you draw mulitple lines
        availLeftLineGraphic[counter+1].lineTo(availRightHandler[counter].x, availRightHandler[counter].y);
        availStaffLevelGroup.add(availLeftLineGraphic[counter+1]);
    }
    
    // attaching events to the handler
    availCenterHandler[counter].events.onDragStart.add(availHandlerDragStart);
    availCenterHandler[counter].events.onDragUpdate.add(availHandlerDragUpdate);
    availCenterHandler[counter].events.onDragStop.add(availHandlerDragStop);
    availBar[counter].events.onInputOver.add(availBarInputOver);
    availBar[counter].events.onInputOut.add(availBarInputOut);

    availStaffLevelGroup.add(availBar[counter]);
    availStaffLevelGroup.add(availCenterHandler[counter]);
    availStaffLevelGroup.add(availLeftHandler[counter]);
    availStaffLevelGroup.add(availRightHandler[counter]);
    availStaffLevelGroup.add(availLeftLineGraphic[counter]);
    availStaffLevelGroup.add(availMiddleLineGraphic[counter]);

}



function createminRequiredHourBar( hourlyLevel, counter, minRequiredLevelsLength ){

    // creating a bar sprite and positioning it according to minRequired staff levels
    minRequiredBar[counter] = game.add.sprite(xAxisRef + ((counter-1)*30), yAxisRef - hourlyLevel*10, 'transparent');
    minRequiredBar[counter].height = hourlyLevel*10;
    minRequiredBar[counter].width = 30;
    minRequiredBar[counter].inputEnabled = true;
    minRequiredBar[counter].barName = "Bar-" + counter;
    minRequiredBar[counter].barId = counter;
    //minRequiredBar[counter].alpha = 0.8;

    
    // creating and aligning the handler to the minRequire bar sprite
    minReqCenterHandler[counter] = game.add.sprite(xAxisRef + ((counter-1)*30) + 15, yAxisRef - hourlyLevel*10, 'node');
    minReqCenterHandler[counter].minReqCenterHandlerId = counter;
    minReqCenterHandler[counter].anchor.set(0.5);
    minReqCenterHandler[counter].scale.setTo(0.05);
    minReqCenterHandler[counter].inputEnabled = true;
    minReqCenterHandler[counter].input.allowHorizontalDrag = false;
    minReqCenterHandler[counter].input.enableDrag(false, true);
    minReqCenterHandler[counter].input.useHandCursor = true;
    minReqCenterHandler[counter].input.boundsRect = positiveBounds;
    minReqCenterHandler[counter].visible = false;

    if(counter == 1){
        minReqRightHandler[counter-1] = game.add.sprite(xAxisRef, yAxisRef, 'node');
        minReqRightHandler[counter-1].minReqLeftHandlerId = counter-1;
        minReqRightHandler[counter-1].anchor.set(0.5);
        minReqRightHandler[counter-1].scale.setTo(0.04); 
        minReqRightHandler[counter-1].visible = false; 
    }

    // creating and aligning the handler to the minRequire bar sprite
    minReqLeftHandler[counter] = game.add.sprite(xAxisRef + ((counter-1)*30), yAxisRef - hourlyLevel*10, 'node');
    minReqLeftHandler[counter].minReqLeftHandlerId = counter;
    minReqLeftHandler[counter].visible = false;
    minReqLeftHandler[counter].anchor.set(0.5);
    minReqLeftHandler[counter].scale.setTo(0.04);   

    // creating and aligning the handler to the minRequire bar sprite
    minReqRightHandler[counter] = game.add.sprite(xAxisRef + ((counter)*30), yAxisRef - hourlyLevel*10, 'node');
    minReqRightHandler[counter].minReqRightHandlerId = counter;
    minReqRightHandler[counter].visible = false;
    minReqRightHandler[counter].anchor.set(0.5);
    minReqRightHandler[counter].scale.setTo(0.04);
  
    
    minReqLeftLine[counter] = new Phaser.Line(minReqLeftHandler[counter].x, minReqLeftHandler[counter].y, minReqRightHandler[counter-1].x, minReqRightHandler[counter-1].y);         
    minReqMiddleLine[counter] = new Phaser.Line(minReqLeftHandler[counter].x, minReqLeftHandler[counter].y, minReqRightHandler[counter].x, minReqRightHandler[counter].y);         
    
    minReqLeftLineGraphic[counter]=game.add.graphics(0,0);
    minReqLeftLineGraphic[counter].lineStyle(2, minReqColor, 1);
    minReqLeftLineGraphic[counter].moveTo(minReqLeftHandler[counter].x, minReqLeftHandler[counter].y);//moving position of graphic if you draw mulitple lines
    minReqLeftLineGraphic[counter].lineTo(minReqRightHandler[counter-1].x, minReqRightHandler[counter-1].y);

    minReqMiddleLineGraphic[counter]=game.add.graphics(0,0);
    minReqMiddleLineGraphic[counter].lineStyle(2, minReqColor, 1);
    minReqMiddleLineGraphic[counter].moveTo(minReqLeftHandler[counter].x, minReqLeftHandler[counter].y);//moving position of graphic if you draw mulitple lines
    minReqMiddleLineGraphic[counter].lineTo(minReqRightHandler[counter].x, minReqRightHandler[counter].y);

    if(counter ==  minRequiredLevelsLength){
        minReqLeftHandler[counter+1] = game.add.sprite(xAxisRef + ((counter)*30), yAxisRef, 'node');
        minReqLeftHandler[counter+1].minReqLeftHandlerId = counter+1;
        minReqLeftHandler[counter+1].anchor.set(0.5);
        minReqLeftHandler[counter+1].scale.setTo(0.04); 
        minReqLeftHandler[counter+1].visible = false; 
        minReqLeftLine[counter+1] = new Phaser.Line(minReqLeftHandler[counter+1].x, minReqLeftHandler[counter+1].y, minReqRightHandler[counter].x, minReqRightHandler[counter].y);                   
        minReqLeftLineGraphic[counter+1]=game.add.graphics(0,0);
        minReqLeftLineGraphic[counter+1].lineStyle(2, minReqColor, 1);
        minReqLeftLineGraphic[counter+1].moveTo(minReqLeftHandler[counter+1].x, minReqLeftHandler[counter+1].y);//moving position of graphic if you draw mulitple lines
        minReqLeftLineGraphic[counter+1].lineTo(minReqRightHandler[counter].x, minReqRightHandler[counter].y);
        minReqStaffLevelGroup.add(minReqLeftLineGraphic[counter+1]);
    }
    
    // attaching events to the handler
    minReqCenterHandler[counter].events.onDragStart.add(minReqHandlerDragStart);
    minReqCenterHandler[counter].events.onDragUpdate.add(minReqHandlerDragUpdate);
    minReqCenterHandler[counter].events.onDragStop.add(minReqHandlerDragStop);
    minRequiredBar[counter].events.onInputOver.add(minReqBarInputOver);
    minRequiredBar[counter].events.onInputOut.add(minReqBarInputOut);

    minReqStaffLevelGroup.add(minRequiredBar[counter]);
    minReqStaffLevelGroup.add(minReqCenterHandler[counter]);
    minReqStaffLevelGroup.add(minReqLeftHandler[counter]);
    minReqStaffLevelGroup.add(minReqRightHandler[counter]);
    minReqStaffLevelGroup.add(minReqLeftLineGraphic[counter]);
    minReqStaffLevelGroup.add(minReqMiddleLineGraphic[counter]);

}


function createmaxRequiredHourBar( hourlyLevel, counter, maxRequiredLevelsLength ){

    // creating a bar sprite and positioning it according to maxRequired staff levels
    maxRequiredBar[counter] = game.add.sprite(xAxisRef + ((counter-1)*30), yAxisRef - hourlyLevel*10, 'transparent');
    maxRequiredBar[counter].height = hourlyLevel*10;
    maxRequiredBar[counter].width = 30;
    maxRequiredBar[counter].inputEnabled = true;
    maxRequiredBar[counter].barName = "Bar-" + counter;
    maxRequiredBar[counter].barId = counter;
    //maxRequiredBar[counter].alpha = 0.8;

    
    // creating and aligning the handler to the maxRequire bar sprite
    maxReqCenterHandler[counter] = game.add.sprite(xAxisRef + ((counter-1)*30) + 15, yAxisRef - hourlyLevel*10, 'node');
    maxReqCenterHandler[counter].maxReqCenterHandlerId = counter;
    maxReqCenterHandler[counter].anchor.set(0.5);
    maxReqCenterHandler[counter].scale.setTo(0.05);
    maxReqCenterHandler[counter].inputEnabled = true;
    maxReqCenterHandler[counter].input.allowHorizontalDrag = false;
    maxReqCenterHandler[counter].input.enableDrag(false, true);
    maxReqCenterHandler[counter].input.useHandCursor = true;
    maxReqCenterHandler[counter].input.boundsRect = positiveBounds;
    maxReqCenterHandler[counter].visible = false;

    if(counter == 1){
        maxReqRightHandler[counter-1] = game.add.sprite(xAxisRef, yAxisRef, 'node');
        maxReqRightHandler[counter-1].maxReqLeftHandlerId = counter-1;
        maxReqRightHandler[counter-1].anchor.set(0.5);
        maxReqRightHandler[counter-1].scale.setTo(0.04); 
        maxReqRightHandler[counter-1].visible = false; 
    }

    // creating and aligning the handler to the maxRequire bar sprite
    maxReqLeftHandler[counter] = game.add.sprite(xAxisRef + ((counter-1)*30), yAxisRef - hourlyLevel*10, 'node');
    maxReqLeftHandler[counter].maxReqLeftHandlerId = counter;
    maxReqLeftHandler[counter].visible = false;
    maxReqLeftHandler[counter].anchor.set(0.5);
    maxReqLeftHandler[counter].scale.setTo(0.04);   

    // creating and aligning the handler to the maxRequire bar sprite
    maxReqRightHandler[counter] = game.add.sprite(xAxisRef + ((counter)*30), yAxisRef - hourlyLevel*10, 'node');
    maxReqRightHandler[counter].maxReqRightHandlerId = counter;
    maxReqRightHandler[counter].visible = false;
    maxReqRightHandler[counter].anchor.set(0.5);
    maxReqRightHandler[counter].scale.setTo(0.04);
  
    
    maxReqLeftLine[counter] = new Phaser.Line(maxReqLeftHandler[counter].x, maxReqLeftHandler[counter].y, maxReqRightHandler[counter-1].x, maxReqRightHandler[counter-1].y);         
    maxReqMiddleLine[counter] = new Phaser.Line(maxReqLeftHandler[counter].x, maxReqLeftHandler[counter].y, maxReqRightHandler[counter].x, maxReqRightHandler[counter].y);         
    
    maxReqLeftLineGraphic[counter] = game.add.graphics(0,0);
    maxReqLeftLineGraphic[counter].lineStyle(2, maxReqColor, 1);
    maxReqLeftLineGraphic[counter].moveTo(maxReqLeftHandler[counter].x, maxReqLeftHandler[counter].y);//moving position of graphic if you draw mulitple lines
    maxReqLeftLineGraphic[counter].lineTo(maxReqRightHandler[counter-1].x, maxReqRightHandler[counter-1].y);

    maxReqMiddleLineGraphic[counter] = game.add.graphics(0,0);
    maxReqMiddleLineGraphic[counter].lineStyle(2, maxReqColor, 1);
    maxReqMiddleLineGraphic[counter].moveTo(maxReqLeftHandler[counter].x, maxReqLeftHandler[counter].y);//moving position of graphic if you draw mulitple lines
    maxReqMiddleLineGraphic[counter].lineTo(maxReqRightHandler[counter].x, maxReqRightHandler[counter].y);

    if(counter ==  maxRequiredLevelsLength){
        maxReqLeftHandler[counter+1] = game.add.sprite(xAxisRef + ((counter)*30), yAxisRef, 'node');
        maxReqLeftHandler[counter+1].maxReqLeftHandlerId = counter+1;
        maxReqLeftHandler[counter+1].anchor.set(0.5);
        maxReqLeftHandler[counter+1].scale.setTo(0.04); 
        maxReqLeftHandler[counter+1].visible = false; 
        maxReqLeftLine[counter+1] = new Phaser.Line(maxReqLeftHandler[counter+1].x, maxReqLeftHandler[counter+1].y, maxReqRightHandler[counter].x, maxReqRightHandler[counter].y);                   
        maxReqLeftLineGraphic[counter+1] = game.add.graphics(0,0);
        maxReqLeftLineGraphic[counter+1].lineStyle(2, maxReqColor, 1);
        maxReqLeftLineGraphic[counter+1].moveTo(maxReqLeftHandler[counter+1].x, maxReqLeftHandler[counter+1].y);//moving position of graphic if you draw mulitple lines
        maxReqLeftLineGraphic[counter+1].lineTo(maxReqRightHandler[counter].x, maxReqRightHandler[counter].y);
        maxReqStaffLevelGroup.add(maxReqLeftLineGraphic[counter+1]);
    }
    
    // attaching events to the handler
    maxReqCenterHandler[counter].events.onDragStart.add(maxReqHandlerDragStart);
    maxReqCenterHandler[counter].events.onDragUpdate.add(maxReqHandlerDragUpdate);
    maxReqCenterHandler[counter].events.onDragStop.add(maxReqHandlerDragStop);
    maxRequiredBar[counter].events.onInputOver.add(maxReqBarInputOver);
    maxRequiredBar[counter].events.onInputOut.add(maxReqBarInputOut);

    maxReqStaffLevelGroup.add(maxRequiredBar[counter]);
    maxReqStaffLevelGroup.add(maxReqCenterHandler[counter]);
    maxReqStaffLevelGroup.add(maxReqLeftHandler[counter]);
    maxReqStaffLevelGroup.add(maxReqRightHandler[counter]);
    maxReqStaffLevelGroup.add(maxReqLeftLineGraphic[counter]);
    maxReqStaffLevelGroup.add(maxReqMiddleLineGraphic[counter]);

}

function createSickHourBar( hourlyLevel, counter, sickLevelsLength ){


    // creating a bar sprite and positioning it according to sick staff levels
    sickBar[counter] = game.add.sprite(xAxisRef + ((counter-1)*30), yAxisRef, 'sky');
    sickBar[counter].height = hourlyLevel*10;
    sickBar[counter].width = 30;
    sickBar[counter].inputEnabled = true;
    sickBar[counter].barName = "Bar-" + counter;
    sickBar[counter].barId = counter;
    sickBar[counter].alpha = 0.8;

    
    // creating and aligning the handler to the sick bar sprite
    sickCenterHandler[counter] = game.add.sprite(xAxisRef + ((counter-1)*30) + 15, yAxisRef + hourlyLevel*10, 'node');
    sickCenterHandler[counter].sickCenterHandlerId = counter;
    sickCenterHandler[counter].anchor.set(0.5);
    sickCenterHandler[counter].scale.setTo(0.05);
    sickCenterHandler[counter].inputEnabled = true;
    sickCenterHandler[counter].input.allowHorizontalDrag = false;
    sickCenterHandler[counter].input.enableDrag(false, true);
    sickCenterHandler[counter].input.useHandCursor = true;
    sickCenterHandler[counter].input.boundsRect = negativeBounds;
    sickCenterHandler[counter].visible = false;

    if(counter == 1){
        sickRightHandler[counter-1] = game.add.sprite(xAxisRef, yAxisRef, 'node');
        sickRightHandler[counter-1].sickLeftHandlerId = counter-1;
        sickRightHandler[counter-1].anchor.set(0.5);
        sickRightHandler[counter-1].scale.setTo(0.04); 
        sickRightHandler[counter-1].visible = false; 
    }

    // creating and aligning the handler to the sick bar sprite
    sickLeftHandler[counter] = game.add.sprite(xAxisRef + ((counter-1)*30), yAxisRef + hourlyLevel*10, 'node');
    sickLeftHandler[counter].sickLeftHandlerId = counter;
    sickLeftHandler[counter].visible = false;
    sickLeftHandler[counter].anchor.set(0.5);
    sickLeftHandler[counter].scale.setTo(0.04);   

    // creating and aligning the handler to the sick bar sprite
    sickRightHandler[counter] = game.add.sprite(xAxisRef + ((counter)*30), yAxisRef + hourlyLevel*10, 'node');
    sickRightHandler[counter].sickRightHandlerId = counter;
    sickRightHandler[counter].visible = false;
    sickRightHandler[counter].anchor.set(0.5);
    sickRightHandler[counter].scale.setTo(0.04);
  
    
    sickLeftLine[counter] = new Phaser.Line(sickLeftHandler[counter].x, sickLeftHandler[counter].y, sickRightHandler[counter-1].x, sickRightHandler[counter-1].y);         
    sickMiddleLine[counter] = new Phaser.Line(sickLeftHandler[counter].x, sickLeftHandler[counter].y, sickRightHandler[counter].x, sickRightHandler[counter].y);         
    
    sickLeftLineGraphic[counter]=game.add.graphics(0,0);
    sickLeftLineGraphic[counter].lineStyle(2, sickColor, 1);
    sickLeftLineGraphic[counter].moveTo(sickLeftHandler[counter].x, sickLeftHandler[counter].y);//moving position of graphic if you draw mulitple lines
    sickLeftLineGraphic[counter].lineTo(sickRightHandler[counter-1].x, sickRightHandler[counter-1].y);

    sickMiddleLineGraphic[counter]=game.add.graphics(0,0);
    sickMiddleLineGraphic[counter].lineStyle(2, sickColor, 1);
    sickMiddleLineGraphic[counter].moveTo(sickLeftHandler[counter].x, sickLeftHandler[counter].y);//moving position of graphic if you draw mulitple lines
    sickMiddleLineGraphic[counter].lineTo(sickRightHandler[counter].x, sickRightHandler[counter].y);

    if(counter ==  sickLevelsLength){
        sickLeftHandler[counter+1] = game.add.sprite(xAxisRef + ((counter)*30), yAxisRef, 'node');
        sickLeftHandler[counter+1].sickLeftHandlerId = counter+1;
        sickLeftHandler[counter+1].anchor.set(0.5);
        sickLeftHandler[counter+1].scale.setTo(0.04); 
        sickLeftHandler[counter+1].visible = false; 
        sickLeftLine[counter+1] = new Phaser.Line(sickLeftHandler[counter+1].x, sickLeftHandler[counter+1].y, sickRightHandler[counter].x, sickRightHandler[counter].y);                   
        sickLeftLineGraphic[counter+1]=game.add.graphics(0,0);
        sickLeftLineGraphic[counter+1].lineStyle(2, sickColor, 1);
        sickLeftLineGraphic[counter+1].moveTo(sickLeftHandler[counter+1].x, sickLeftHandler[counter+1].y);//moving position of graphic if you draw mulitple lines
        sickLeftLineGraphic[counter+1].lineTo(sickRightHandler[counter].x, sickRightHandler[counter].y);
        sickStaffLevelGroup.add(sickLeftLineGraphic[counter+1]);
    }
    
    // attaching events to the handler
    sickCenterHandler[counter].events.onDragStart.add(sickHandlerDragStart);
    sickCenterHandler[counter].events.onDragUpdate.add(sickHandlerDragUpdate);
    sickCenterHandler[counter].events.onDragStop.add(sickHandlerDragStop);
    sickBar[counter].events.onInputOver.add(sickBarInputOver);
    sickBar[counter].events.onInputOut.add(sickBarInputOut);

    sickStaffLevelGroup.add(sickBar[counter]);
    sickStaffLevelGroup.add(sickCenterHandler[counter]);
    sickStaffLevelGroup.add(sickLeftHandler[counter]);
    sickStaffLevelGroup.add(sickRightHandler[counter]);
    sickStaffLevelGroup.add(sickLeftLineGraphic[counter]);
    sickStaffLevelGroup.add(sickMiddleLineGraphic[counter]);

}




function availBarInputOver(bar, pointer) {    
    //barId = bar.barId;
    //availCenterHandler[barId].visible = true;
}

function availBarInputOut(bar, pointer) {
    //barId = bar.barId;
    //availCenterHandler[barId].visible = false;    
}

function minReqBarInputOver(bar, pointer) {    
    //barId = bar.barId;
    //minReqCenterHandler[barId].visible = true;
}

function minReqBarInputOut(bar, pointer) {
    //barId = bar.barId;
    //minReqCenterHandler[barId].visible = false;    
}

function maxReqBarInputOver(bar, pointer) {    
    //barId = bar.barId;
    //maxReqCenterHandler[barId].visible = true;
}

function maxReqBarInputOut(bar, pointer) {
    //barId = bar.barId;
    //maxReqCenterHandler[barId].visible = false;    
}

function sickBarInputOver(bar, pointer) {    
    //barId = bar.barId;
    //sickCenterHandler[barId].visible = true;
}

function sickBarInputOut(bar, pointer) {
    //barId = bar.barId;
    //sickCenterHandler[barId].visible = false;    
}







function availHandlerDragStart(handler, pointer, x, y) {
    
    availHandlerStartYCoordinate = y;
    availBarHeight =  availBar[availCenterHandlerId].height;
}

function availHandlerDragUpdate(handler, pointer, x, y, snapOnDrag, fromStart) {
    availCenterHandlerId = handler.availCenterHandlerId;
    //console.log("availCenterHandlerId", availCenterHandlerId);
    availDragDist = availHandlerStartYCoordinate - handler.y;
    //console.log("availDragDist", availDragDist);
    if(!isNaN(availDragDist)){
        availBar[availCenterHandlerId].height = availBarHeight + Math.floor(availDragDist / 10) * 10;
        availBar[availCenterHandlerId].y = (Math.ceil(handler.y / 10) * 10); 

        availRightHandler[availCenterHandlerId].y = availLeftHandler[availCenterHandlerId].y = availBar[availCenterHandlerId].y;
    
        availLeftLine[availCenterHandlerId].fromSprite(availLeftHandler[availCenterHandlerId], availRightHandler[availCenterHandlerId-1], false);
        availLeftLine[availCenterHandlerId+1].fromSprite(availLeftHandler[availCenterHandlerId+1], availRightHandler[availCenterHandlerId], false);
        availMiddleLine[availCenterHandlerId].fromSprite(availLeftHandler[availCenterHandlerId], availRightHandler[availCenterHandlerId], false);
        
        availLeftLineGraphic[availCenterHandlerId].clear();
        availLeftLineGraphic[availCenterHandlerId].lineStyle(2, availColor, 1);        
        availLeftLineGraphic[availCenterHandlerId].moveTo(availLeftHandler[availCenterHandlerId].x, availLeftHandler[availCenterHandlerId].y);//moving position of graphic if you draw mulitple lines
        availLeftLineGraphic[availCenterHandlerId].lineTo(availRightHandler[availCenterHandlerId-1].x, availRightHandler[availCenterHandlerId-1].y);

        availLeftLineGraphic[availCenterHandlerId+1].clear();
        availLeftLineGraphic[availCenterHandlerId+1].lineStyle(2, availColor, 1);        
        availLeftLineGraphic[availCenterHandlerId+1].moveTo(availLeftHandler[availCenterHandlerId+1].x, availLeftHandler[availCenterHandlerId+1].y);//moving position of graphic if you draw mulitple lines
        availLeftLineGraphic[availCenterHandlerId+1].lineTo(availRightHandler[availCenterHandlerId].x, availRightHandler[availCenterHandlerId].y);

        availMiddleLineGraphic[availCenterHandlerId].clear();
        availMiddleLineGraphic[availCenterHandlerId].lineStyle(2, availColor, 1);
        availMiddleLineGraphic[availCenterHandlerId].moveTo(availLeftHandler[availCenterHandlerId].x, availLeftHandler[availCenterHandlerId].y);//moving position of graphic if you draw mulitple lines
        availMiddleLineGraphic[availCenterHandlerId].lineTo(availRightHandler[availCenterHandlerId].x, availRightHandler[availCenterHandlerId].y);
    
        updateConflictArea(availCenterHandlerId);
    }

}


function availHandlerDragStop(handler, pointer) {

    if(handler.y !== availBar[availCenterHandlerId].y){
        handler.y = availBar[availCenterHandlerId].y;
    }


}

function minReqHandlerDragStart(handler, pointer, x, y) {
    
    minReqHandlerStartYCoordinate = y;
    minRequiredBarHeight =  minRequiredBar[minReqCenterHandlerId].height;
}

function minReqHandlerDragUpdate(handler, pointer, x, y, snapOnDrag, fromStart) {
    minReqCenterHandlerId = handler.minReqCenterHandlerId;
    //console.log("minReqCenterHandlerId", minReqCenterHandlerId);
    minReqDragDist = minReqHandlerStartYCoordinate - handler.y;
    //console.log("minReqDragDist", minReqDragDist);
    if(!isNaN(minReqDragDist)){
        minRequiredBar[minReqCenterHandlerId].height = minRequiredBarHeight + Math.floor(minReqDragDist / 10) * 10;
        minRequiredBar[minReqCenterHandlerId].y = (Math.ceil(handler.y / 10) * 10); 

        minReqRightHandler[minReqCenterHandlerId].y = minReqLeftHandler[minReqCenterHandlerId].y = minRequiredBar[minReqCenterHandlerId].y;
    
        minReqLeftLine[minReqCenterHandlerId].fromSprite(minReqLeftHandler[minReqCenterHandlerId], minReqRightHandler[minReqCenterHandlerId-1], false);
        minReqLeftLine[minReqCenterHandlerId+1].fromSprite(minReqLeftHandler[minReqCenterHandlerId+1], minReqRightHandler[minReqCenterHandlerId], false);
        minReqMiddleLine[minReqCenterHandlerId].fromSprite(minReqLeftHandler[minReqCenterHandlerId], minReqRightHandler[minReqCenterHandlerId], false);
        
        minReqLeftLineGraphic[minReqCenterHandlerId].clear();
        minReqLeftLineGraphic[minReqCenterHandlerId].lineStyle(2, minReqColor, 1);        
        minReqLeftLineGraphic[minReqCenterHandlerId].moveTo(minReqLeftHandler[minReqCenterHandlerId].x, minReqLeftHandler[minReqCenterHandlerId].y);//moving position of graphic if you draw mulitple lines
        minReqLeftLineGraphic[minReqCenterHandlerId].lineTo(minReqRightHandler[minReqCenterHandlerId-1].x, minReqRightHandler[minReqCenterHandlerId-1].y);

        minReqLeftLineGraphic[minReqCenterHandlerId+1].clear();
        minReqLeftLineGraphic[minReqCenterHandlerId+1].lineStyle(2, minReqColor, 1);        
        minReqLeftLineGraphic[minReqCenterHandlerId+1].moveTo(minReqLeftHandler[minReqCenterHandlerId+1].x, minReqLeftHandler[minReqCenterHandlerId+1].y);//moving position of graphic if you draw mulitple lines
        minReqLeftLineGraphic[minReqCenterHandlerId+1].lineTo(minReqRightHandler[minReqCenterHandlerId].x, minReqRightHandler[minReqCenterHandlerId].y);

        minReqMiddleLineGraphic[minReqCenterHandlerId].clear();
        minReqMiddleLineGraphic[minReqCenterHandlerId].lineStyle(2, minReqColor, 1);
        minReqMiddleLineGraphic[minReqCenterHandlerId].moveTo(minReqLeftHandler[minReqCenterHandlerId].x, minReqLeftHandler[minReqCenterHandlerId].y);//moving position of graphic if you draw mulitple lines
        minReqMiddleLineGraphic[minReqCenterHandlerId].lineTo(minReqRightHandler[minReqCenterHandlerId].x, minReqRightHandler[minReqCenterHandlerId].y);

        updateConflictArea(minReqCenterHandlerId)    
    }
}


function minReqHandlerDragStop(handler, pointer) {

    if(handler.y !== minRequiredBar[minReqCenterHandlerId].y){
        handler.y = minRequiredBar[minReqCenterHandlerId].y;
    }

}


function maxReqHandlerDragStart(handler, pointer, x, y) {
    
    maxReqHandlerStartYCoordinate = y;
    maxRequiredBarHeight =  maxRequiredBar[maxReqCenterHandlerId].height;
}

function maxReqHandlerDragUpdate(handler, pointer, x, y, snapOnDrag, fromStart) {
    maxReqCenterHandlerId = handler.maxReqCenterHandlerId;
    //console.log("maxReqCenterHandlerId", maxReqCenterHandlerId);
    maxReqDragDist = maxReqHandlerStartYCoordinate - handler.y;
    //console.log("maxReqDragDist", maxReqDragDist);
    if(!isNaN(maxReqDragDist)){
        maxRequiredBar[maxReqCenterHandlerId].height = maxRequiredBarHeight + Math.floor(maxReqDragDist / 10) * 10;
        maxRequiredBar[maxReqCenterHandlerId].y = (Math.ceil(handler.y / 10) * 10); 

        maxReqRightHandler[maxReqCenterHandlerId].y = maxReqLeftHandler[maxReqCenterHandlerId].y = maxRequiredBar[maxReqCenterHandlerId].y;
    
        maxReqLeftLine[maxReqCenterHandlerId].fromSprite(maxReqLeftHandler[maxReqCenterHandlerId], maxReqRightHandler[maxReqCenterHandlerId-1], false);
        maxReqLeftLine[maxReqCenterHandlerId+1].fromSprite(maxReqLeftHandler[maxReqCenterHandlerId+1], maxReqRightHandler[maxReqCenterHandlerId], false);
        maxReqMiddleLine[maxReqCenterHandlerId].fromSprite(maxReqLeftHandler[maxReqCenterHandlerId], maxReqRightHandler[maxReqCenterHandlerId], false);
        
        maxReqLeftLineGraphic[maxReqCenterHandlerId].clear();
        maxReqLeftLineGraphic[maxReqCenterHandlerId].lineStyle(2, maxReqColor, 1);        
        maxReqLeftLineGraphic[maxReqCenterHandlerId].moveTo(maxReqLeftHandler[maxReqCenterHandlerId].x, maxReqLeftHandler[maxReqCenterHandlerId].y);//moving position of graphic if you draw mulitple lines
        maxReqLeftLineGraphic[maxReqCenterHandlerId].lineTo(maxReqRightHandler[maxReqCenterHandlerId-1].x, maxReqRightHandler[maxReqCenterHandlerId-1].y);

        maxReqLeftLineGraphic[maxReqCenterHandlerId+1].clear();
        maxReqLeftLineGraphic[maxReqCenterHandlerId+1].lineStyle(2, maxReqColor, 1);        
        maxReqLeftLineGraphic[maxReqCenterHandlerId+1].moveTo(maxReqLeftHandler[maxReqCenterHandlerId+1].x, maxReqLeftHandler[maxReqCenterHandlerId+1].y);//moving position of graphic if you draw mulitple lines
        maxReqLeftLineGraphic[maxReqCenterHandlerId+1].lineTo(maxReqRightHandler[maxReqCenterHandlerId].x, maxReqRightHandler[maxReqCenterHandlerId].y);

        maxReqMiddleLineGraphic[maxReqCenterHandlerId].clear();
        maxReqMiddleLineGraphic[maxReqCenterHandlerId].lineStyle(2, maxReqColor, 1);
        maxReqMiddleLineGraphic[maxReqCenterHandlerId].moveTo(maxReqLeftHandler[maxReqCenterHandlerId].x, maxReqLeftHandler[maxReqCenterHandlerId].y);//moving position of graphic if you draw mulitple lines
        maxReqMiddleLineGraphic[maxReqCenterHandlerId].lineTo(maxReqRightHandler[maxReqCenterHandlerId].x, maxReqRightHandler[maxReqCenterHandlerId].y);

        updateConflictArea(maxReqCenterHandlerId)
    }
}


function maxReqHandlerDragStop(handler, pointer) {

    if(handler.y !== maxRequiredBar[maxReqCenterHandlerId].y){
        handler.y = maxRequiredBar[maxReqCenterHandlerId].y;
    }
    
}


function sickHandlerDragStart(handler, pointer, x, y) {
    
    sickHandlerStartYCoordinate = y;
    sickBarHeight =  sickBar[sickCenterHandlerId].height;
}

function sickHandlerDragUpdate(handler, pointer, x, y, snapOnDrag, fromStart) {
    sickCenterHandlerId = handler.sickCenterHandlerId;
    //console.log("sickCenterHandlerId", sickCenterHandlerId);
    sickDragDist = sickHandlerStartYCoordinate - handler.y;
    //console.log("sickDragDist", sickDragDist);
    if(!isNaN(sickDragDist)){
        sickBar[sickCenterHandlerId].height = sickBarHeight - Math.floor(sickDragDist / 10) * 10;
        sickBar[sickCenterHandlerId].y = yAxisRef; 

        sickRightHandler[sickCenterHandlerId].y = sickLeftHandler[sickCenterHandlerId].y = sickBar[sickCenterHandlerId].bottom;
    
        sickLeftLine[sickCenterHandlerId].fromSprite(sickLeftHandler[sickCenterHandlerId], sickRightHandler[sickCenterHandlerId-1], false);
        sickLeftLine[sickCenterHandlerId+1].fromSprite(sickLeftHandler[sickCenterHandlerId+1], sickRightHandler[sickCenterHandlerId], false);
        sickMiddleLine[sickCenterHandlerId].fromSprite(sickLeftHandler[sickCenterHandlerId], sickRightHandler[sickCenterHandlerId], false);
        
        sickLeftLineGraphic[sickCenterHandlerId].clear();
        sickLeftLineGraphic[sickCenterHandlerId].lineStyle(2, sickColor, 1);        
        sickLeftLineGraphic[sickCenterHandlerId].moveTo(sickLeftHandler[sickCenterHandlerId].x, sickLeftHandler[sickCenterHandlerId].y);//moving position of graphic if you draw mulitple lines
        sickLeftLineGraphic[sickCenterHandlerId].lineTo(sickRightHandler[sickCenterHandlerId-1].x, sickRightHandler[sickCenterHandlerId-1].y);

        sickLeftLineGraphic[sickCenterHandlerId+1].clear();
        sickLeftLineGraphic[sickCenterHandlerId+1].lineStyle(2, sickColor, 1);        
        sickLeftLineGraphic[sickCenterHandlerId+1].moveTo(sickLeftHandler[sickCenterHandlerId+1].x, sickLeftHandler[sickCenterHandlerId+1].y);//moving position of graphic if you draw mulitple lines
        sickLeftLineGraphic[sickCenterHandlerId+1].lineTo(sickRightHandler[sickCenterHandlerId].x, sickRightHandler[sickCenterHandlerId].y);

        sickMiddleLineGraphic[sickCenterHandlerId].clear();
        sickMiddleLineGraphic[sickCenterHandlerId].lineStyle(2, sickColor, 1);
        sickMiddleLineGraphic[sickCenterHandlerId].moveTo(sickLeftHandler[sickCenterHandlerId].x, sickLeftHandler[sickCenterHandlerId].y);//moving position of graphic if you draw mulitple lines
        sickMiddleLineGraphic[sickCenterHandlerId].lineTo(sickRightHandler[sickCenterHandlerId].x, sickRightHandler[sickCenterHandlerId].y);
    }

}


function sickHandlerDragStop(handler, pointer) {

    if(handler.y !== sickBar[sickCenterHandlerId].bottom){
        handler.y = sickBar[sickCenterHandlerId].bottom;
    }
    //updateConflictArea(sickCenterHandlerId);

}


function update() {

}

function render() {
    // counter = 1;
    // // loop to iterate over minRequired staff levels for each hour 
    // for (var eachHour in shiftData.minRequiredLevels) {
    //     if (shiftData.minRequiredLevels.hasOwnProperty(eachHour)) {
              //game.debug.geom(minReqLeftLine[counter]);
    //         game.debug.geom(minReqMiddleLine[counter]);
    //         if(counter ==  minRequiredLevelsLength){
    //             game.debug.geom(minReqLeftLine[counter+1]);
    //         }    
    //         counter++;
    //     }
    // }  
}

function createScale() {
    xAxis = new Phaser.Line(0, yAxisRef + 1, 800, yAxisRef + 1);
    yAxis = new Phaser.Line(xAxisRef, 00, xAxisRef, 800);
    var xAxisGraphics=game.add.graphics(0,0);
    xAxisGraphics.lineStyle(2, 0xb1b1b1);
    xAxisGraphics.moveTo(xAxis.start.x,xAxis.start.y);//moving position of graphic if you draw mulitple lines    
    xAxisGraphics.lineTo(xAxis.end.x,xAxis.end.y);
    xAxisGraphics.endFill();
    var yAxisGraphics=game.add.graphics(0,0);
    yAxisGraphics.lineStyle(2, 0xb1b1b1);
    yAxisGraphics.moveTo(yAxis.start.x,yAxis.start.y);//moving position of graphic if you draw mulitple lines    
    yAxisGraphics.lineTo(yAxis.end.x,yAxis.end.y);
    yAxisGraphics.endFill();
    var loopCounter = 1;
    while(loopCounter <=25){
        if(loopCounter == 1){
            loopCounter++;
            continue;
        }
        xScaleText[loopCounter] = game.add.text(xAxisRef + (hourScale * (loopCounter-1)), yAxisRef + 15, loopCounter-1, {fontSize : "12px"});
        xScaleText[loopCounter].anchor.setTo(0.5, 0.5);
        xScaleText[loopCounter].addColor('#b1b1b1');

        if((loopCounter-1) % 3 ==0){                            
            yScaleTextPositive[loopCounter] = game.add.text((xAxisRef-10), yAxisRef - ((loopCounter-1)*10), loopCounter-1, {fontSize : "12px"});
            yScaleTextPositive[loopCounter].anchor.setTo(0.5, 0.5);
            yScaleTextPositive[loopCounter].addColor('#b1b1b1');

            yScaleTextNegative[loopCounter] = game.add.text((xAxisRef-10), yAxisRef + ((loopCounter-1)*10), -(loopCounter-1), {fontSize : "12px"});
            yScaleTextNegative[loopCounter].anchor.setTo(0.5, 0.5);
            yScaleTextNegative[loopCounter].addColor('#b1b1b1');             
        }       


        loopCounter++;
    }

}


function indicateConflictAreas(){

    console.log("in indicateConflictAreas");
    var loopCounter = 1;
    for (var eachHour in shiftData.availableLevels) {
        if (shiftData.minRequiredLevels.hasOwnProperty(eachHour)) {
            y1 = shiftData.minRequiredLevels[eachHour] * 10;    // y coordinate of reqLevels 
            y2 = shiftData.availableLevels[eachHour] * 10;      // y coordinate of availableLevels

            if(y1 > y2){
                x1 = xAxisRef + ((loopCounter-1) * hourScale);    //x coordinate of the Hour Bar (same for both levels)
                x2 = xAxisRef + ((loopCounter) * hourScale);    //(x coordinate + width) of the Hour Bar (same for both levels)
                
                underStaffPolygon[loopCounter] = new Phaser.Polygon();
                underStaffPolygon[loopCounter].setTo([
                    {x: x1, y: yAxisRef - y1 },
                    {x: x2, y: yAxisRef - y1 },
                    {x: x2, y: yAxisRef - y2 },
                    {x: x1, y: yAxisRef - y2 },                   
                ]);
                //console.log( underStaffPolygon[loopCounter]);
                underStaffGraphic[loopCounter] = game.add.graphics(0, 0);
                //underStaffGraphic[loopCounter].lineStyle(2, 0xcacacb);
                underStaffGraphic[loopCounter].beginFill(0X9c1003);
                underStaffGraphic[loopCounter].drawPolygon(underStaffPolygon[loopCounter].points);
                //underStaffGraphic[loopCounter].alpha = 0.5;
                underStaffGraphic[loopCounter].endFill();
                polygonGroup.add(underStaffGraphic[loopCounter]); 
            }
              
        }
        if (shiftData.maxRequiredLevels.hasOwnProperty(eachHour)) {
            y1 = shiftData.maxRequiredLevels[eachHour] * 10;    // y coordinate of reqLevels 
            y2 = shiftData.availableLevels[eachHour] * 10;      // y coordinate of availableLevels

            if(y1 < y2){
                x1 = xAxisRef + ((loopCounter-1) * hourScale);    //x coordinate of the Hour Bar (same for both levels)
                x2 = xAxisRef + ((loopCounter) * hourScale);    //(x coordinate + width) of the Hour Bar (same for both levels)
                
                overStaffPolygon[loopCounter] = new Phaser.Polygon();
                overStaffPolygon[loopCounter].setTo([
                    {x: x1, y: yAxisRef - y1 },
                    {x: x2, y: yAxisRef - y1 },
                    {x: x2, y: yAxisRef - y2 },
                    {x: x1, y: yAxisRef - y2 },                   
                ]);
                overStaffGraphic[loopCounter] = game.add.graphics(0, 0);
                //overStaffGraphic[loopCounter].lineStyle(2, 0xcacacb);
                overStaffGraphic[loopCounter].beginFill(0xe3da7d);
                overStaffGraphic[loopCounter].drawPolygon(overStaffPolygon[loopCounter].points);
                //overStaffGraphic[loopCounter].alpha = 0.4;
                overStaffGraphic[loopCounter].endFill();
                polygonGroup.add(overStaffGraphic[loopCounter]); 
            }
              
        }        
                        
            loopCounter++;
    } 
}

function updateConflictArea(counter){

    console.log("in updateConflictArea");
    polygonExists = false;
    if(typeof underStaffGraphic[counter] !== "undefined"){
        underStaffGraphic[counter].clear();
    }

    if(typeof overStaffGraphic[counter] !== "undefined"){
        overStaffGraphic[counter].clear();
    }

    let availBarY = availBar[counter].y;
    let availBarX = availBar[counter].x;
    let minReqBarY = minRequiredBar[counter].y;
    let minReqBarX = minRequiredBar[counter].x;
    let maxReqBarY = maxRequiredBar[counter].y;
    let maxReqBarX = maxRequiredBar[counter].x;
    let conflict;

    if(availBarY > minReqBarY){
        conflict = "underStaff";
    }
    else if(availBarY < maxReqBarY){
        conflict = "overStaff";
    }
    else{
        conflict =  null;
    }

    switch(conflict) {
        case "underStaff":
            underStaffPolygon[counter] = new Phaser.Polygon();
            underStaffPolygon[counter].setTo([
            {x: availBarX, y: availBarY },
            {x: availBarX + hourScale, y: availBarY },
            {x: minReqBarX + hourScale, y: minReqBarY },
            {x: minReqBarX, y: minReqBarY },                   
            ]);
            underStaffGraphic[counter] = game.add.graphics(0, 0);
            underStaffGraphic[counter].beginFill(0X9c1003);
            underStaffGraphic[counter].drawPolygon(underStaffPolygon[counter].points);
            underStaffGraphic[counter].endFill();
            polygonGroup.add(underStaffGraphic[counter]);
            break;
             
        case "overStaff":
            overStaffPolygon[counter] = new Phaser.Polygon();
            overStaffPolygon[counter].setTo([
            {x: availBarX, y: availBarY },
            {x: availBarX + hourScale, y: availBarY },
            {x: maxReqBarX + hourScale, y: maxReqBarY },
            {x: maxReqBarX, y: maxReqBarY },                   
            ]);
            console.log(overStaffPolygon[counter]);
            overStaffGraphic[counter] = game.add.graphics(0, 0);
            overStaffGraphic[counter].beginFill(0xe3da7d);
            overStaffGraphic[counter].drawPolygon(overStaffPolygon[counter].points);
            overStaffGraphic[counter].endFill();    
            polygonGroup.add(overStaffGraphic[counter]);             
            break;

        default:

    }    
}


$('.onTopSelect').on('change',function(){
    //minReqStaffLevelGroup.visible = false;
    activeGroup = this.value;
    switch(activeGroup) {
        case "avail":
            game.world.bringToTop(availStaffLevelGroup);
            for (var i in availCenterHandler) {
                minReqCenterHandler[i].visible = false;
                maxReqCenterHandler[i].visible = false;
                availCenterHandler[i].visible = true;
                sickCenterHandler[i].visible = false;
            }
            break;

        case "minReq":
            game.world.bringToTop(minReqStaffLevelGroup);
            for (var i in minReqCenterHandler) {
                minReqCenterHandler[i].visible = true;
                maxReqCenterHandler[i].visible = false;
                availCenterHandler[i].visible = false;
                sickCenterHandler[i].visible = false;
            }            
            break;

        case "maxReq":
            game.world.bringToTop(maxReqStaffLevelGroup);
            for (var i in maxReqCenterHandler) {
                minReqCenterHandler[i].visible = false;
                maxReqCenterHandler[i].visible = true;
                availCenterHandler[i].visible = false;
                sickCenterHandler[i].visible = false;
            } 
            break;

        case "sick":
            game.world.bringToTop(sickStaffLevelGroup);
            for (var i in sickCenterHandler) {
                minReqCenterHandler[i].visible = false;
                maxReqCenterHandler[i].visible = false;
                availCenterHandler[i].visible = false;
                sickCenterHandler[i].visible = true;

            } 
            break;                         

        default:
            game.world.bringToTop(availStaffLevelGroup);
            game.world.bringToTop(minReqStaffLevelGroup);
            game.world.bringToTop(maxReqStaffLevelGroup);
            game.world.bringToTop(polygonGroup);
            for (var i in maxReqCenterHandler) {
                minReqCenterHandler[i].visible = false;
                maxReqCenterHandler[i].visible = false;
                availCenterHandler[i].visible = false;
                sickCenterHandler[i].visible = false;
            } 
    }
});

</script>

</body>
</html>
